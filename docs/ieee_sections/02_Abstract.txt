Abstract—This paper introduces Vectron, a distributed vector database designed to deliver durable ingestion and low-latency similarity search over high-dimensional embeddings. The system addresses a fundamental tension in production vector search: approximate indexes are optimized for query speed but are typically in-memory and weakly durable, while strongly consistent storage layers provide durability and recoverability but often fail to meet tight latency requirements for similarity retrieval. Vectron resolves this tension by combining shard-level Raft replication with a local HNSW index and a persistent PebbleDB storage engine. Each shard is a Raft group with an on-disk state machine; writes are serialized through Raft, persisted in Pebble, and reflected in the HNSW index with configurable synchronous or asynchronous update behavior.

Vectron is architected around a strict separation of control and data planes. A dedicated Placement Driver maintains global metadata and shard placement under Raft, ensuring that routing and placement decisions are consistent and recoverable. Workers form the data plane, hosting multiple shard replicas and executing search queries locally. The system exposes a public API via an API Gateway that orchestrates routing, enforces authentication and rate limiting, aggregates results across workers, and optionally invokes a standalone Reranker service for post-search refinement. This gateway-centric design stabilizes external APIs while allowing internal data-plane evolution.

The system includes multiple caching layers to reduce latency and load, including a gateway-level search cache with optional distributed backing, worker-level response caches, and reranker caches keyed by query and candidate sets. These caches are integrated into the request path and are tuned via explicit configuration. The search path is designed for tunability: search fanout, candidate limits, reranking timeouts, and HNSW parameters are all exposed, enabling operators to select precise points on the recall–latency and consistency–throughput trade-off surfaces.

Vectron’s persistence model integrates a write-ahead log and periodic snapshots for the HNSW index, ensuring that index state is recoverable after failures. State machine snapshots capture PebbleDB state and are used for Raft recovery, while HNSW WAL replay reconstitutes index state during restart. The system also supports a search-only worker mode, enabling read scaling via replicated index state without write responsibilities.

This paper provides a comprehensive description of Vectron’s architecture, algorithms, and implementation. It details routing and shard management, the Raft-based write path, the HNSW search algorithm and its configuration surface, caching strategies, and reranker integration. It also describes the system’s operational workflow, including failure handling and recovery, and discusses the test and benchmark framework embedded in the codebase. The evaluation methodology measures latency, throughput, and search quality metrics such as recall and NDCG, providing a structured basis for assessing performance. Vectron illustrates a practical and extensible design for production vector search that emphasizes durability, explicit trade-offs, and operational transparency.
