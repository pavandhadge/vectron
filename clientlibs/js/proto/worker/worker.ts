// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.10.1
//   protoc               v3.19.6
// source: worker/worker.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type ClientWritableStream,
  type handleClientStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "vectron.worker.v1";

/** Vector messages */
export interface Vector {
  id: string;
  vector: number[];
  metadata: Buffer;
}

export interface StoreVectorRequest {
  shardId: string;
  vector: Vector | undefined;
}

export interface StoreVectorResponse {
}

export interface BatchStoreVectorRequest {
  shardId: string;
  vectors: Vector[];
}

export interface BatchStoreVectorResponse {
  stored: number;
}

export interface GetVectorRequest {
  shardId: string;
  id: string;
}

export interface GetVectorResponse {
  vector: Vector | undefined;
}

export interface DeleteVectorRequest {
  shardId: string;
  id: string;
}

export interface DeleteVectorResponse {
}

export interface SearchRequest {
  shardId: string;
  vector: number[];
  k: number;
  bruteForce: boolean;
  linearizable: boolean;
  collection: string;
}

export interface SearchResponse {
  ids: string[];
  scores: number[];
}

export interface BatchSearchRequest {
  requests: SearchRequest[];
}

export interface BatchSearchResponse {
  responses: SearchResponse[];
}

/** Key-value messages */
export interface KeyValuePair {
  key: Buffer;
  value: Buffer;
}

export interface PutRequest {
  shardId: string;
  kv: KeyValuePair | undefined;
}

export interface PutResponse {
}

export interface GetRequest {
  shardId: string;
  key: Buffer;
}

export interface GetResponse {
  kv: KeyValuePair | undefined;
}

export interface DeleteRequest {
  shardId: string;
  key: Buffer;
}

export interface DeleteResponse {
}

/** Control/Admin messages */
export interface StatusRequest {
  shardId: string;
}

export interface StatusResponse {
  status: string;
}

export interface FlushRequest {
  shardId: string;
}

export interface FlushResponse {
}

function createBaseVector(): Vector {
  return { id: "", vector: [], metadata: Buffer.alloc(0) };
}

export const Vector: MessageFns<Vector> = {
  encode(message: Vector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    writer.uint32(18).fork();
    for (const v of message.vector) {
      writer.float(v);
    }
    writer.join();
    if (message.metadata.length !== 0) {
      writer.uint32(26).bytes(message.metadata);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Vector {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag === 21) {
            message.vector.push(reader.float());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.vector.push(reader.float());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Vector {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      vector: globalThis.Array.isArray(object?.vector) ? object.vector.map((e: any) => globalThis.Number(e)) : [],
      metadata: isSet(object.metadata) ? Buffer.from(bytesFromBase64(object.metadata)) : Buffer.alloc(0),
    };
  },

  toJSON(message: Vector): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.vector?.length) {
      obj.vector = message.vector;
    }
    if (message.metadata.length !== 0) {
      obj.metadata = base64FromBytes(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Vector>, I>>(base?: I): Vector {
    return Vector.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Vector>, I>>(object: I): Vector {
    const message = createBaseVector();
    message.id = object.id ?? "";
    message.vector = object.vector?.map((e) => e) || [];
    message.metadata = object.metadata ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseStoreVectorRequest(): StoreVectorRequest {
  return { shardId: "0", vector: undefined };
}

export const StoreVectorRequest: MessageFns<StoreVectorRequest> = {
  encode(message: StoreVectorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shardId !== "0") {
      writer.uint32(8).uint64(message.shardId);
    }
    if (message.vector !== undefined) {
      Vector.encode(message.vector, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StoreVectorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStoreVectorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.shardId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.vector = Vector.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StoreVectorRequest {
    return {
      shardId: isSet(object.shardId) ? globalThis.String(object.shardId) : "0",
      vector: isSet(object.vector) ? Vector.fromJSON(object.vector) : undefined,
    };
  },

  toJSON(message: StoreVectorRequest): unknown {
    const obj: any = {};
    if (message.shardId !== "0") {
      obj.shardId = message.shardId;
    }
    if (message.vector !== undefined) {
      obj.vector = Vector.toJSON(message.vector);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StoreVectorRequest>, I>>(base?: I): StoreVectorRequest {
    return StoreVectorRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StoreVectorRequest>, I>>(object: I): StoreVectorRequest {
    const message = createBaseStoreVectorRequest();
    message.shardId = object.shardId ?? "0";
    message.vector = (object.vector !== undefined && object.vector !== null)
      ? Vector.fromPartial(object.vector)
      : undefined;
    return message;
  },
};

function createBaseStoreVectorResponse(): StoreVectorResponse {
  return {};
}

export const StoreVectorResponse: MessageFns<StoreVectorResponse> = {
  encode(_: StoreVectorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StoreVectorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStoreVectorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): StoreVectorResponse {
    return {};
  },

  toJSON(_: StoreVectorResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<StoreVectorResponse>, I>>(base?: I): StoreVectorResponse {
    return StoreVectorResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StoreVectorResponse>, I>>(_: I): StoreVectorResponse {
    const message = createBaseStoreVectorResponse();
    return message;
  },
};

function createBaseBatchStoreVectorRequest(): BatchStoreVectorRequest {
  return { shardId: "0", vectors: [] };
}

export const BatchStoreVectorRequest: MessageFns<BatchStoreVectorRequest> = {
  encode(message: BatchStoreVectorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shardId !== "0") {
      writer.uint32(8).uint64(message.shardId);
    }
    for (const v of message.vectors) {
      Vector.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchStoreVectorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchStoreVectorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.shardId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.vectors.push(Vector.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchStoreVectorRequest {
    return {
      shardId: isSet(object.shardId) ? globalThis.String(object.shardId) : "0",
      vectors: globalThis.Array.isArray(object?.vectors) ? object.vectors.map((e: any) => Vector.fromJSON(e)) : [],
    };
  },

  toJSON(message: BatchStoreVectorRequest): unknown {
    const obj: any = {};
    if (message.shardId !== "0") {
      obj.shardId = message.shardId;
    }
    if (message.vectors?.length) {
      obj.vectors = message.vectors.map((e) => Vector.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchStoreVectorRequest>, I>>(base?: I): BatchStoreVectorRequest {
    return BatchStoreVectorRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchStoreVectorRequest>, I>>(object: I): BatchStoreVectorRequest {
    const message = createBaseBatchStoreVectorRequest();
    message.shardId = object.shardId ?? "0";
    message.vectors = object.vectors?.map((e) => Vector.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchStoreVectorResponse(): BatchStoreVectorResponse {
  return { stored: 0 };
}

export const BatchStoreVectorResponse: MessageFns<BatchStoreVectorResponse> = {
  encode(message: BatchStoreVectorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stored !== 0) {
      writer.uint32(8).int32(message.stored);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchStoreVectorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchStoreVectorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.stored = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchStoreVectorResponse {
    return { stored: isSet(object.stored) ? globalThis.Number(object.stored) : 0 };
  },

  toJSON(message: BatchStoreVectorResponse): unknown {
    const obj: any = {};
    if (message.stored !== 0) {
      obj.stored = Math.round(message.stored);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchStoreVectorResponse>, I>>(base?: I): BatchStoreVectorResponse {
    return BatchStoreVectorResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchStoreVectorResponse>, I>>(object: I): BatchStoreVectorResponse {
    const message = createBaseBatchStoreVectorResponse();
    message.stored = object.stored ?? 0;
    return message;
  },
};

function createBaseGetVectorRequest(): GetVectorRequest {
  return { shardId: "0", id: "" };
}

export const GetVectorRequest: MessageFns<GetVectorRequest> = {
  encode(message: GetVectorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shardId !== "0") {
      writer.uint32(8).uint64(message.shardId);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetVectorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetVectorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.shardId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetVectorRequest {
    return {
      shardId: isSet(object.shardId) ? globalThis.String(object.shardId) : "0",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: GetVectorRequest): unknown {
    const obj: any = {};
    if (message.shardId !== "0") {
      obj.shardId = message.shardId;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetVectorRequest>, I>>(base?: I): GetVectorRequest {
    return GetVectorRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetVectorRequest>, I>>(object: I): GetVectorRequest {
    const message = createBaseGetVectorRequest();
    message.shardId = object.shardId ?? "0";
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseGetVectorResponse(): GetVectorResponse {
  return { vector: undefined };
}

export const GetVectorResponse: MessageFns<GetVectorResponse> = {
  encode(message: GetVectorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vector !== undefined) {
      Vector.encode(message.vector, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetVectorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetVectorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.vector = Vector.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetVectorResponse {
    return { vector: isSet(object.vector) ? Vector.fromJSON(object.vector) : undefined };
  },

  toJSON(message: GetVectorResponse): unknown {
    const obj: any = {};
    if (message.vector !== undefined) {
      obj.vector = Vector.toJSON(message.vector);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetVectorResponse>, I>>(base?: I): GetVectorResponse {
    return GetVectorResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetVectorResponse>, I>>(object: I): GetVectorResponse {
    const message = createBaseGetVectorResponse();
    message.vector = (object.vector !== undefined && object.vector !== null)
      ? Vector.fromPartial(object.vector)
      : undefined;
    return message;
  },
};

function createBaseDeleteVectorRequest(): DeleteVectorRequest {
  return { shardId: "0", id: "" };
}

export const DeleteVectorRequest: MessageFns<DeleteVectorRequest> = {
  encode(message: DeleteVectorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shardId !== "0") {
      writer.uint32(8).uint64(message.shardId);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteVectorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteVectorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.shardId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteVectorRequest {
    return {
      shardId: isSet(object.shardId) ? globalThis.String(object.shardId) : "0",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: DeleteVectorRequest): unknown {
    const obj: any = {};
    if (message.shardId !== "0") {
      obj.shardId = message.shardId;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteVectorRequest>, I>>(base?: I): DeleteVectorRequest {
    return DeleteVectorRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteVectorRequest>, I>>(object: I): DeleteVectorRequest {
    const message = createBaseDeleteVectorRequest();
    message.shardId = object.shardId ?? "0";
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseDeleteVectorResponse(): DeleteVectorResponse {
  return {};
}

export const DeleteVectorResponse: MessageFns<DeleteVectorResponse> = {
  encode(_: DeleteVectorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteVectorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteVectorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteVectorResponse {
    return {};
  },

  toJSON(_: DeleteVectorResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteVectorResponse>, I>>(base?: I): DeleteVectorResponse {
    return DeleteVectorResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteVectorResponse>, I>>(_: I): DeleteVectorResponse {
    const message = createBaseDeleteVectorResponse();
    return message;
  },
};

function createBaseSearchRequest(): SearchRequest {
  return { shardId: "0", vector: [], k: 0, bruteForce: false, linearizable: false, collection: "" };
}

export const SearchRequest: MessageFns<SearchRequest> = {
  encode(message: SearchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shardId !== "0") {
      writer.uint32(8).uint64(message.shardId);
    }
    writer.uint32(18).fork();
    for (const v of message.vector) {
      writer.float(v);
    }
    writer.join();
    if (message.k !== 0) {
      writer.uint32(24).int32(message.k);
    }
    if (message.bruteForce !== false) {
      writer.uint32(32).bool(message.bruteForce);
    }
    if (message.linearizable !== false) {
      writer.uint32(40).bool(message.linearizable);
    }
    if (message.collection !== "") {
      writer.uint32(50).string(message.collection);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.shardId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag === 21) {
            message.vector.push(reader.float());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.vector.push(reader.float());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.k = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.bruteForce = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.linearizable = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.collection = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest {
    return {
      shardId: isSet(object.shardId) ? globalThis.String(object.shardId) : "0",
      vector: globalThis.Array.isArray(object?.vector) ? object.vector.map((e: any) => globalThis.Number(e)) : [],
      k: isSet(object.k) ? globalThis.Number(object.k) : 0,
      bruteForce: isSet(object.bruteForce) ? globalThis.Boolean(object.bruteForce) : false,
      linearizable: isSet(object.linearizable) ? globalThis.Boolean(object.linearizable) : false,
      collection: isSet(object.collection) ? globalThis.String(object.collection) : "",
    };
  },

  toJSON(message: SearchRequest): unknown {
    const obj: any = {};
    if (message.shardId !== "0") {
      obj.shardId = message.shardId;
    }
    if (message.vector?.length) {
      obj.vector = message.vector;
    }
    if (message.k !== 0) {
      obj.k = Math.round(message.k);
    }
    if (message.bruteForce !== false) {
      obj.bruteForce = message.bruteForce;
    }
    if (message.linearizable !== false) {
      obj.linearizable = message.linearizable;
    }
    if (message.collection !== "") {
      obj.collection = message.collection;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchRequest>, I>>(base?: I): SearchRequest {
    return SearchRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchRequest>, I>>(object: I): SearchRequest {
    const message = createBaseSearchRequest();
    message.shardId = object.shardId ?? "0";
    message.vector = object.vector?.map((e) => e) || [];
    message.k = object.k ?? 0;
    message.bruteForce = object.bruteForce ?? false;
    message.linearizable = object.linearizable ?? false;
    message.collection = object.collection ?? "";
    return message;
  },
};

function createBaseSearchResponse(): SearchResponse {
  return { ids: [], scores: [] };
}

export const SearchResponse: MessageFns<SearchResponse> = {
  encode(message: SearchResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ids) {
      writer.uint32(10).string(v!);
    }
    writer.uint32(18).fork();
    for (const v of message.scores) {
      writer.float(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        }
        case 2: {
          if (tag === 21) {
            message.scores.push(reader.float());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.scores.push(reader.float());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse {
    return {
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
      scores: globalThis.Array.isArray(object?.scores) ? object.scores.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: SearchResponse): unknown {
    const obj: any = {};
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    if (message.scores?.length) {
      obj.scores = message.scores;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchResponse>, I>>(base?: I): SearchResponse {
    return SearchResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchResponse>, I>>(object: I): SearchResponse {
    const message = createBaseSearchResponse();
    message.ids = object.ids?.map((e) => e) || [];
    message.scores = object.scores?.map((e) => e) || [];
    return message;
  },
};

function createBaseBatchSearchRequest(): BatchSearchRequest {
  return { requests: [] };
}

export const BatchSearchRequest: MessageFns<BatchSearchRequest> = {
  encode(message: BatchSearchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.requests) {
      SearchRequest.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchSearchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchSearchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requests.push(SearchRequest.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchSearchRequest {
    return {
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => SearchRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchSearchRequest): unknown {
    const obj: any = {};
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => SearchRequest.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchSearchRequest>, I>>(base?: I): BatchSearchRequest {
    return BatchSearchRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchSearchRequest>, I>>(object: I): BatchSearchRequest {
    const message = createBaseBatchSearchRequest();
    message.requests = object.requests?.map((e) => SearchRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchSearchResponse(): BatchSearchResponse {
  return { responses: [] };
}

export const BatchSearchResponse: MessageFns<BatchSearchResponse> = {
  encode(message: BatchSearchResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.responses) {
      SearchResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchSearchResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchSearchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.responses.push(SearchResponse.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchSearchResponse {
    return {
      responses: globalThis.Array.isArray(object?.responses)
        ? object.responses.map((e: any) => SearchResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchSearchResponse): unknown {
    const obj: any = {};
    if (message.responses?.length) {
      obj.responses = message.responses.map((e) => SearchResponse.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchSearchResponse>, I>>(base?: I): BatchSearchResponse {
    return BatchSearchResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchSearchResponse>, I>>(object: I): BatchSearchResponse {
    const message = createBaseBatchSearchResponse();
    message.responses = object.responses?.map((e) => SearchResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseKeyValuePair(): KeyValuePair {
  return { key: Buffer.alloc(0), value: Buffer.alloc(0) };
}

export const KeyValuePair: MessageFns<KeyValuePair> = {
  encode(message: KeyValuePair, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyValuePair {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyValuePair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = Buffer.from(reader.bytes());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyValuePair {
    return {
      key: isSet(object.key) ? Buffer.from(bytesFromBase64(object.key)) : Buffer.alloc(0),
      value: isSet(object.value) ? Buffer.from(bytesFromBase64(object.value)) : Buffer.alloc(0),
    };
  },

  toJSON(message: KeyValuePair): unknown {
    const obj: any = {};
    if (message.key.length !== 0) {
      obj.key = base64FromBytes(message.key);
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeyValuePair>, I>>(base?: I): KeyValuePair {
    return KeyValuePair.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeyValuePair>, I>>(object: I): KeyValuePair {
    const message = createBaseKeyValuePair();
    message.key = object.key ?? Buffer.alloc(0);
    message.value = object.value ?? Buffer.alloc(0);
    return message;
  },
};

function createBasePutRequest(): PutRequest {
  return { shardId: "0", kv: undefined };
}

export const PutRequest: MessageFns<PutRequest> = {
  encode(message: PutRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shardId !== "0") {
      writer.uint32(8).uint64(message.shardId);
    }
    if (message.kv !== undefined) {
      KeyValuePair.encode(message.kv, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PutRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.shardId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.kv = KeyValuePair.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutRequest {
    return {
      shardId: isSet(object.shardId) ? globalThis.String(object.shardId) : "0",
      kv: isSet(object.kv) ? KeyValuePair.fromJSON(object.kv) : undefined,
    };
  },

  toJSON(message: PutRequest): unknown {
    const obj: any = {};
    if (message.shardId !== "0") {
      obj.shardId = message.shardId;
    }
    if (message.kv !== undefined) {
      obj.kv = KeyValuePair.toJSON(message.kv);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutRequest>, I>>(base?: I): PutRequest {
    return PutRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutRequest>, I>>(object: I): PutRequest {
    const message = createBasePutRequest();
    message.shardId = object.shardId ?? "0";
    message.kv = (object.kv !== undefined && object.kv !== null) ? KeyValuePair.fromPartial(object.kv) : undefined;
    return message;
  },
};

function createBasePutResponse(): PutResponse {
  return {};
}

export const PutResponse: MessageFns<PutResponse> = {
  encode(_: PutResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PutResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PutResponse {
    return {};
  },

  toJSON(_: PutResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PutResponse>, I>>(base?: I): PutResponse {
    return PutResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutResponse>, I>>(_: I): PutResponse {
    const message = createBasePutResponse();
    return message;
  },
};

function createBaseGetRequest(): GetRequest {
  return { shardId: "0", key: Buffer.alloc(0) };
}

export const GetRequest: MessageFns<GetRequest> = {
  encode(message: GetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shardId !== "0") {
      writer.uint32(8).uint64(message.shardId);
    }
    if (message.key.length !== 0) {
      writer.uint32(18).bytes(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.shardId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRequest {
    return {
      shardId: isSet(object.shardId) ? globalThis.String(object.shardId) : "0",
      key: isSet(object.key) ? Buffer.from(bytesFromBase64(object.key)) : Buffer.alloc(0),
    };
  },

  toJSON(message: GetRequest): unknown {
    const obj: any = {};
    if (message.shardId !== "0") {
      obj.shardId = message.shardId;
    }
    if (message.key.length !== 0) {
      obj.key = base64FromBytes(message.key);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRequest>, I>>(base?: I): GetRequest {
    return GetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRequest>, I>>(object: I): GetRequest {
    const message = createBaseGetRequest();
    message.shardId = object.shardId ?? "0";
    message.key = object.key ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseGetResponse(): GetResponse {
  return { kv: undefined };
}

export const GetResponse: MessageFns<GetResponse> = {
  encode(message: GetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kv !== undefined) {
      KeyValuePair.encode(message.kv, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.kv = KeyValuePair.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetResponse {
    return { kv: isSet(object.kv) ? KeyValuePair.fromJSON(object.kv) : undefined };
  },

  toJSON(message: GetResponse): unknown {
    const obj: any = {};
    if (message.kv !== undefined) {
      obj.kv = KeyValuePair.toJSON(message.kv);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetResponse>, I>>(base?: I): GetResponse {
    return GetResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetResponse>, I>>(object: I): GetResponse {
    const message = createBaseGetResponse();
    message.kv = (object.kv !== undefined && object.kv !== null) ? KeyValuePair.fromPartial(object.kv) : undefined;
    return message;
  },
};

function createBaseDeleteRequest(): DeleteRequest {
  return { shardId: "0", key: Buffer.alloc(0) };
}

export const DeleteRequest: MessageFns<DeleteRequest> = {
  encode(message: DeleteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shardId !== "0") {
      writer.uint32(8).uint64(message.shardId);
    }
    if (message.key.length !== 0) {
      writer.uint32(18).bytes(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.shardId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteRequest {
    return {
      shardId: isSet(object.shardId) ? globalThis.String(object.shardId) : "0",
      key: isSet(object.key) ? Buffer.from(bytesFromBase64(object.key)) : Buffer.alloc(0),
    };
  },

  toJSON(message: DeleteRequest): unknown {
    const obj: any = {};
    if (message.shardId !== "0") {
      obj.shardId = message.shardId;
    }
    if (message.key.length !== 0) {
      obj.key = base64FromBytes(message.key);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteRequest>, I>>(base?: I): DeleteRequest {
    return DeleteRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteRequest>, I>>(object: I): DeleteRequest {
    const message = createBaseDeleteRequest();
    message.shardId = object.shardId ?? "0";
    message.key = object.key ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseDeleteResponse(): DeleteResponse {
  return {};
}

export const DeleteResponse: MessageFns<DeleteResponse> = {
  encode(_: DeleteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteResponse {
    return {};
  },

  toJSON(_: DeleteResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteResponse>, I>>(base?: I): DeleteResponse {
    return DeleteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteResponse>, I>>(_: I): DeleteResponse {
    const message = createBaseDeleteResponse();
    return message;
  },
};

function createBaseStatusRequest(): StatusRequest {
  return { shardId: "0" };
}

export const StatusRequest: MessageFns<StatusRequest> = {
  encode(message: StatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shardId !== "0") {
      writer.uint32(8).uint64(message.shardId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.shardId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatusRequest {
    return { shardId: isSet(object.shardId) ? globalThis.String(object.shardId) : "0" };
  },

  toJSON(message: StatusRequest): unknown {
    const obj: any = {};
    if (message.shardId !== "0") {
      obj.shardId = message.shardId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StatusRequest>, I>>(base?: I): StatusRequest {
    return StatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StatusRequest>, I>>(object: I): StatusRequest {
    const message = createBaseStatusRequest();
    message.shardId = object.shardId ?? "0";
    return message;
  },
};

function createBaseStatusResponse(): StatusResponse {
  return { status: "" };
}

export const StatusResponse: MessageFns<StatusResponse> = {
  encode(message: StatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatusResponse {
    return { status: isSet(object.status) ? globalThis.String(object.status) : "" };
  },

  toJSON(message: StatusResponse): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StatusResponse>, I>>(base?: I): StatusResponse {
    return StatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StatusResponse>, I>>(object: I): StatusResponse {
    const message = createBaseStatusResponse();
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseFlushRequest(): FlushRequest {
  return { shardId: "0" };
}

export const FlushRequest: MessageFns<FlushRequest> = {
  encode(message: FlushRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shardId !== "0") {
      writer.uint32(8).uint64(message.shardId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FlushRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFlushRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.shardId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FlushRequest {
    return { shardId: isSet(object.shardId) ? globalThis.String(object.shardId) : "0" };
  },

  toJSON(message: FlushRequest): unknown {
    const obj: any = {};
    if (message.shardId !== "0") {
      obj.shardId = message.shardId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FlushRequest>, I>>(base?: I): FlushRequest {
    return FlushRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FlushRequest>, I>>(object: I): FlushRequest {
    const message = createBaseFlushRequest();
    message.shardId = object.shardId ?? "0";
    return message;
  },
};

function createBaseFlushResponse(): FlushResponse {
  return {};
}

export const FlushResponse: MessageFns<FlushResponse> = {
  encode(_: FlushResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FlushResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFlushResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): FlushResponse {
    return {};
  },

  toJSON(_: FlushResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<FlushResponse>, I>>(base?: I): FlushResponse {
    return FlushResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FlushResponse>, I>>(_: I): FlushResponse {
    const message = createBaseFlushResponse();
    return message;
  },
};

/** The worker service definition. */
export type WorkerServiceService = typeof WorkerServiceService;
export const WorkerServiceService = {
  /** Vector operations */
  storeVector: {
    path: "/vectron.worker.v1.WorkerService/StoreVector",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: StoreVectorRequest): Buffer => Buffer.from(StoreVectorRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): StoreVectorRequest => StoreVectorRequest.decode(value),
    responseSerialize: (value: StoreVectorResponse): Buffer => Buffer.from(StoreVectorResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StoreVectorResponse => StoreVectorResponse.decode(value),
  },
  batchStoreVector: {
    path: "/vectron.worker.v1.WorkerService/BatchStoreVector",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BatchStoreVectorRequest): Buffer =>
      Buffer.from(BatchStoreVectorRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): BatchStoreVectorRequest => BatchStoreVectorRequest.decode(value),
    responseSerialize: (value: BatchStoreVectorResponse): Buffer =>
      Buffer.from(BatchStoreVectorResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BatchStoreVectorResponse => BatchStoreVectorResponse.decode(value),
  },
  /** Streaming batch upsert for large ingests */
  streamBatchStoreVector: {
    path: "/vectron.worker.v1.WorkerService/StreamBatchStoreVector",
    requestStream: true,
    responseStream: false,
    requestSerialize: (value: BatchStoreVectorRequest): Buffer =>
      Buffer.from(BatchStoreVectorRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): BatchStoreVectorRequest => BatchStoreVectorRequest.decode(value),
    responseSerialize: (value: BatchStoreVectorResponse): Buffer =>
      Buffer.from(BatchStoreVectorResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BatchStoreVectorResponse => BatchStoreVectorResponse.decode(value),
  },
  getVector: {
    path: "/vectron.worker.v1.WorkerService/GetVector",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetVectorRequest): Buffer => Buffer.from(GetVectorRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetVectorRequest => GetVectorRequest.decode(value),
    responseSerialize: (value: GetVectorResponse): Buffer => Buffer.from(GetVectorResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetVectorResponse => GetVectorResponse.decode(value),
  },
  deleteVector: {
    path: "/vectron.worker.v1.WorkerService/DeleteVector",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteVectorRequest): Buffer => Buffer.from(DeleteVectorRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteVectorRequest => DeleteVectorRequest.decode(value),
    responseSerialize: (value: DeleteVectorResponse): Buffer =>
      Buffer.from(DeleteVectorResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteVectorResponse => DeleteVectorResponse.decode(value),
  },
  search: {
    path: "/vectron.worker.v1.WorkerService/Search",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SearchRequest): Buffer => Buffer.from(SearchRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SearchRequest => SearchRequest.decode(value),
    responseSerialize: (value: SearchResponse): Buffer => Buffer.from(SearchResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SearchResponse => SearchResponse.decode(value),
  },
  /** Batch multiple searches into a single RPC */
  batchSearch: {
    path: "/vectron.worker.v1.WorkerService/BatchSearch",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BatchSearchRequest): Buffer => Buffer.from(BatchSearchRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): BatchSearchRequest => BatchSearchRequest.decode(value),
    responseSerialize: (value: BatchSearchResponse): Buffer => Buffer.from(BatchSearchResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BatchSearchResponse => BatchSearchResponse.decode(value),
  },
  /** Key-value operations */
  put: {
    path: "/vectron.worker.v1.WorkerService/Put",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PutRequest): Buffer => Buffer.from(PutRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PutRequest => PutRequest.decode(value),
    responseSerialize: (value: PutResponse): Buffer => Buffer.from(PutResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PutResponse => PutResponse.decode(value),
  },
  get: {
    path: "/vectron.worker.v1.WorkerService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetRequest): Buffer => Buffer.from(GetRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetRequest => GetRequest.decode(value),
    responseSerialize: (value: GetResponse): Buffer => Buffer.from(GetResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetResponse => GetResponse.decode(value),
  },
  delete: {
    path: "/vectron.worker.v1.WorkerService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteRequest): Buffer => Buffer.from(DeleteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteRequest => DeleteRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  /** Control/Admin operations */
  status: {
    path: "/vectron.worker.v1.WorkerService/Status",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: StatusRequest): Buffer => Buffer.from(StatusRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): StatusRequest => StatusRequest.decode(value),
    responseSerialize: (value: StatusResponse): Buffer => Buffer.from(StatusResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StatusResponse => StatusResponse.decode(value),
  },
  flush: {
    path: "/vectron.worker.v1.WorkerService/Flush",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: FlushRequest): Buffer => Buffer.from(FlushRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): FlushRequest => FlushRequest.decode(value),
    responseSerialize: (value: FlushResponse): Buffer => Buffer.from(FlushResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): FlushResponse => FlushResponse.decode(value),
  },
} as const;

export interface WorkerServiceServer extends UntypedServiceImplementation {
  /** Vector operations */
  storeVector: handleUnaryCall<StoreVectorRequest, StoreVectorResponse>;
  batchStoreVector: handleUnaryCall<BatchStoreVectorRequest, BatchStoreVectorResponse>;
  /** Streaming batch upsert for large ingests */
  streamBatchStoreVector: handleClientStreamingCall<BatchStoreVectorRequest, BatchStoreVectorResponse>;
  getVector: handleUnaryCall<GetVectorRequest, GetVectorResponse>;
  deleteVector: handleUnaryCall<DeleteVectorRequest, DeleteVectorResponse>;
  search: handleUnaryCall<SearchRequest, SearchResponse>;
  /** Batch multiple searches into a single RPC */
  batchSearch: handleUnaryCall<BatchSearchRequest, BatchSearchResponse>;
  /** Key-value operations */
  put: handleUnaryCall<PutRequest, PutResponse>;
  get: handleUnaryCall<GetRequest, GetResponse>;
  delete: handleUnaryCall<DeleteRequest, DeleteResponse>;
  /** Control/Admin operations */
  status: handleUnaryCall<StatusRequest, StatusResponse>;
  flush: handleUnaryCall<FlushRequest, FlushResponse>;
}

export interface WorkerServiceClient extends Client {
  /** Vector operations */
  storeVector(
    request: StoreVectorRequest,
    callback: (error: ServiceError | null, response: StoreVectorResponse) => void,
  ): ClientUnaryCall;
  storeVector(
    request: StoreVectorRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: StoreVectorResponse) => void,
  ): ClientUnaryCall;
  storeVector(
    request: StoreVectorRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: StoreVectorResponse) => void,
  ): ClientUnaryCall;
  batchStoreVector(
    request: BatchStoreVectorRequest,
    callback: (error: ServiceError | null, response: BatchStoreVectorResponse) => void,
  ): ClientUnaryCall;
  batchStoreVector(
    request: BatchStoreVectorRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BatchStoreVectorResponse) => void,
  ): ClientUnaryCall;
  batchStoreVector(
    request: BatchStoreVectorRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BatchStoreVectorResponse) => void,
  ): ClientUnaryCall;
  /** Streaming batch upsert for large ingests */
  streamBatchStoreVector(
    callback: (error: ServiceError | null, response: BatchStoreVectorResponse) => void,
  ): ClientWritableStream<BatchStoreVectorRequest>;
  streamBatchStoreVector(
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BatchStoreVectorResponse) => void,
  ): ClientWritableStream<BatchStoreVectorRequest>;
  streamBatchStoreVector(
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BatchStoreVectorResponse) => void,
  ): ClientWritableStream<BatchStoreVectorRequest>;
  streamBatchStoreVector(
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BatchStoreVectorResponse) => void,
  ): ClientWritableStream<BatchStoreVectorRequest>;
  getVector(
    request: GetVectorRequest,
    callback: (error: ServiceError | null, response: GetVectorResponse) => void,
  ): ClientUnaryCall;
  getVector(
    request: GetVectorRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetVectorResponse) => void,
  ): ClientUnaryCall;
  getVector(
    request: GetVectorRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetVectorResponse) => void,
  ): ClientUnaryCall;
  deleteVector(
    request: DeleteVectorRequest,
    callback: (error: ServiceError | null, response: DeleteVectorResponse) => void,
  ): ClientUnaryCall;
  deleteVector(
    request: DeleteVectorRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeleteVectorResponse) => void,
  ): ClientUnaryCall;
  deleteVector(
    request: DeleteVectorRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeleteVectorResponse) => void,
  ): ClientUnaryCall;
  search(
    request: SearchRequest,
    callback: (error: ServiceError | null, response: SearchResponse) => void,
  ): ClientUnaryCall;
  search(
    request: SearchRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SearchResponse) => void,
  ): ClientUnaryCall;
  search(
    request: SearchRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SearchResponse) => void,
  ): ClientUnaryCall;
  /** Batch multiple searches into a single RPC */
  batchSearch(
    request: BatchSearchRequest,
    callback: (error: ServiceError | null, response: BatchSearchResponse) => void,
  ): ClientUnaryCall;
  batchSearch(
    request: BatchSearchRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BatchSearchResponse) => void,
  ): ClientUnaryCall;
  batchSearch(
    request: BatchSearchRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BatchSearchResponse) => void,
  ): ClientUnaryCall;
  /** Key-value operations */
  put(request: PutRequest, callback: (error: ServiceError | null, response: PutResponse) => void): ClientUnaryCall;
  put(
    request: PutRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PutResponse) => void,
  ): ClientUnaryCall;
  put(
    request: PutRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PutResponse) => void,
  ): ClientUnaryCall;
  get(request: GetRequest, callback: (error: ServiceError | null, response: GetResponse) => void): ClientUnaryCall;
  get(
    request: GetRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetResponse) => void,
  ): ClientUnaryCall;
  get(
    request: GetRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetResponse) => void,
  ): ClientUnaryCall;
  delete(
    request: DeleteRequest,
    callback: (error: ServiceError | null, response: DeleteResponse) => void,
  ): ClientUnaryCall;
  delete(
    request: DeleteRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeleteResponse) => void,
  ): ClientUnaryCall;
  delete(
    request: DeleteRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeleteResponse) => void,
  ): ClientUnaryCall;
  /** Control/Admin operations */
  status(
    request: StatusRequest,
    callback: (error: ServiceError | null, response: StatusResponse) => void,
  ): ClientUnaryCall;
  status(
    request: StatusRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: StatusResponse) => void,
  ): ClientUnaryCall;
  status(
    request: StatusRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: StatusResponse) => void,
  ): ClientUnaryCall;
  flush(
    request: FlushRequest,
    callback: (error: ServiceError | null, response: FlushResponse) => void,
  ): ClientUnaryCall;
  flush(
    request: FlushRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: FlushResponse) => void,
  ): ClientUnaryCall;
  flush(
    request: FlushRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: FlushResponse) => void,
  ): ClientUnaryCall;
}

export const WorkerServiceClient = makeGenericClientConstructor(
  WorkerServiceService,
  "vectron.worker.v1.WorkerService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): WorkerServiceClient;
  service: typeof WorkerServiceService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
