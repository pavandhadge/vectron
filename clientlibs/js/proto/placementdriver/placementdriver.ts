// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.10.1
//   protoc               v3.19.6
// source: placementdriver/placementdriver.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "vectron.placementdriver.v1";

/** proto/placement.proto */

export interface GetLeaderRequest {
}

export interface GetLeaderResponse {
  leaderAddress: string;
}

export interface GetWorkerRequest {
  /** Collection name (required) */
  collection: string;
  /**
   * Optional: vector ID for consistent hashing
   * If empty → use collection-level sharding
   */
  vectorId: string;
}

export interface GetWorkerResponse {
  /** Full address: "10.0.0.42:6201" or "worker-3.internal:6201" */
  grpcAddress: string;
  /** Optional: shard info */
  shardId: number;
}

export interface RegisterWorkerRequest {
  grpcAddress: string;
  raftAddress: string;
  /** ["gpu", "large-memory"] */
  capabilities: string[];
  timestamp: string;
  /** Capacity information for capacity-weighted placement */
  cpuCores: number;
  /** Total memory in bytes */
  memoryBytes: string;
  /** Total disk space in bytes */
  diskBytes: string;
  /** Failure domain information for fault-tolerant placement */
  rack: string;
  /** Zone/availability zone (e.g., "us-east-1a") */
  zone: string;
  /** Region (e.g., "us-east-1") */
  region: string;
}

export interface RegisterWorkerResponse {
  /** assigned by placement driver */
  workerId: string;
  success: boolean;
}

export interface ShardLeaderInfo {
  shardId: string;
  leaderId: string;
}

/** ShardMetrics contains per-shard performance metrics for hot-shard detection */
export interface ShardMetrics {
  shardId: string;
  /** Query rate for this shard */
  queriesPerSecond: number;
  /** Number of vectors in this shard */
  vectorCount: string;
  /** Average query latency in milliseconds */
  avgLatencyMs: number;
}

export interface HeartbeatRequest {
  workerId: string;
  timestamp: string;
  vectorCount: string;
  memoryBytes: string;
  shardLeaderInfo: ShardLeaderInfo[];
  /** 0-100 */
  cpuUsagePercent: number;
  /** 0-100 */
  memoryUsagePercent: number;
  /** 0-100 */
  diskUsagePercent: number;
  /** Current query rate */
  queriesPerSecond: number;
  /** Number of shards being served */
  activeShards: string;
  /** Per-shard metrics for hot-shard detection */
  shardMetrics: ShardMetrics[];
}

export interface HeartbeatResponse {
  /** If false → worker is considered dead */
  ok: boolean;
  /** Optional: config updates */
  message: string;
}

export interface ListWorkersRequest {
}

export interface ListWorkersResponse {
  workers: WorkerInfo[];
}

export interface ListWorkersForCollectionRequest {
  collection: string;
}

export interface ListWorkersForCollectionResponse {
  grpcAddresses: string[];
}

export interface WorkerInfo {
  workerId: string;
  grpcAddress: string;
  raftAddress: string;
  collections: string[];
  lastHeartbeat: string;
  healthy: boolean;
  metadata: { [key: string]: string };
}

export interface WorkerInfo_MetadataEntry {
  key: string;
  value: string;
}

/** Future use */
export interface RebalanceRequest {
}

export interface RebalanceResponse {
  started: boolean;
}

export interface CreateCollectionRequest {
  name: string;
  dimension: number;
  distance: string;
}

export interface CreateCollectionResponse {
  success: boolean;
}

export interface ListCollectionsRequest {
}

export interface ListCollectionsResponse {
  collections: string[];
}

export interface DeleteCollectionRequest {
  name: string;
}

export interface DeleteCollectionResponse {
  success: boolean;
}

export interface GetCollectionStatusRequest {
  name: string;
}

export interface GetCollectionStatusResponse {
  name: string;
  dimension: number;
  distance: string;
  shards: ShardStatus[];
}

export interface ShardStatus {
  shardId: number;
  replicas: string[];
  leaderId: string;
  ready: boolean;
}

function createBaseGetLeaderRequest(): GetLeaderRequest {
  return {};
}

export const GetLeaderRequest: MessageFns<GetLeaderRequest> = {
  encode(_: GetLeaderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLeaderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLeaderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetLeaderRequest {
    return {};
  },

  toJSON(_: GetLeaderRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetLeaderRequest>, I>>(base?: I): GetLeaderRequest {
    return GetLeaderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetLeaderRequest>, I>>(_: I): GetLeaderRequest {
    const message = createBaseGetLeaderRequest();
    return message;
  },
};

function createBaseGetLeaderResponse(): GetLeaderResponse {
  return { leaderAddress: "" };
}

export const GetLeaderResponse: MessageFns<GetLeaderResponse> = {
  encode(message: GetLeaderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.leaderAddress !== "") {
      writer.uint32(10).string(message.leaderAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLeaderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLeaderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leaderAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLeaderResponse {
    return { leaderAddress: isSet(object.leaderAddress) ? globalThis.String(object.leaderAddress) : "" };
  },

  toJSON(message: GetLeaderResponse): unknown {
    const obj: any = {};
    if (message.leaderAddress !== "") {
      obj.leaderAddress = message.leaderAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetLeaderResponse>, I>>(base?: I): GetLeaderResponse {
    return GetLeaderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetLeaderResponse>, I>>(object: I): GetLeaderResponse {
    const message = createBaseGetLeaderResponse();
    message.leaderAddress = object.leaderAddress ?? "";
    return message;
  },
};

function createBaseGetWorkerRequest(): GetWorkerRequest {
  return { collection: "", vectorId: "" };
}

export const GetWorkerRequest: MessageFns<GetWorkerRequest> = {
  encode(message: GetWorkerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.collection !== "") {
      writer.uint32(10).string(message.collection);
    }
    if (message.vectorId !== "") {
      writer.uint32(18).string(message.vectorId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWorkerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWorkerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.collection = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.vectorId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWorkerRequest {
    return {
      collection: isSet(object.collection) ? globalThis.String(object.collection) : "",
      vectorId: isSet(object.vectorId) ? globalThis.String(object.vectorId) : "",
    };
  },

  toJSON(message: GetWorkerRequest): unknown {
    const obj: any = {};
    if (message.collection !== "") {
      obj.collection = message.collection;
    }
    if (message.vectorId !== "") {
      obj.vectorId = message.vectorId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWorkerRequest>, I>>(base?: I): GetWorkerRequest {
    return GetWorkerRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWorkerRequest>, I>>(object: I): GetWorkerRequest {
    const message = createBaseGetWorkerRequest();
    message.collection = object.collection ?? "";
    message.vectorId = object.vectorId ?? "";
    return message;
  },
};

function createBaseGetWorkerResponse(): GetWorkerResponse {
  return { grpcAddress: "", shardId: 0 };
}

export const GetWorkerResponse: MessageFns<GetWorkerResponse> = {
  encode(message: GetWorkerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.grpcAddress !== "") {
      writer.uint32(10).string(message.grpcAddress);
    }
    if (message.shardId !== 0) {
      writer.uint32(16).uint32(message.shardId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWorkerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWorkerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.grpcAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.shardId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWorkerResponse {
    return {
      grpcAddress: isSet(object.grpcAddress) ? globalThis.String(object.grpcAddress) : "",
      shardId: isSet(object.shardId) ? globalThis.Number(object.shardId) : 0,
    };
  },

  toJSON(message: GetWorkerResponse): unknown {
    const obj: any = {};
    if (message.grpcAddress !== "") {
      obj.grpcAddress = message.grpcAddress;
    }
    if (message.shardId !== 0) {
      obj.shardId = Math.round(message.shardId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWorkerResponse>, I>>(base?: I): GetWorkerResponse {
    return GetWorkerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWorkerResponse>, I>>(object: I): GetWorkerResponse {
    const message = createBaseGetWorkerResponse();
    message.grpcAddress = object.grpcAddress ?? "";
    message.shardId = object.shardId ?? 0;
    return message;
  },
};

function createBaseRegisterWorkerRequest(): RegisterWorkerRequest {
  return {
    grpcAddress: "",
    raftAddress: "",
    capabilities: [],
    timestamp: "0",
    cpuCores: 0,
    memoryBytes: "0",
    diskBytes: "0",
    rack: "",
    zone: "",
    region: "",
  };
}

export const RegisterWorkerRequest: MessageFns<RegisterWorkerRequest> = {
  encode(message: RegisterWorkerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.grpcAddress !== "") {
      writer.uint32(10).string(message.grpcAddress);
    }
    if (message.raftAddress !== "") {
      writer.uint32(18).string(message.raftAddress);
    }
    for (const v of message.capabilities) {
      writer.uint32(26).string(v!);
    }
    if (message.timestamp !== "0") {
      writer.uint32(32).int64(message.timestamp);
    }
    if (message.cpuCores !== 0) {
      writer.uint32(40).int32(message.cpuCores);
    }
    if (message.memoryBytes !== "0") {
      writer.uint32(48).int64(message.memoryBytes);
    }
    if (message.diskBytes !== "0") {
      writer.uint32(56).int64(message.diskBytes);
    }
    if (message.rack !== "") {
      writer.uint32(66).string(message.rack);
    }
    if (message.zone !== "") {
      writer.uint32(74).string(message.zone);
    }
    if (message.region !== "") {
      writer.uint32(82).string(message.region);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterWorkerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterWorkerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.grpcAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.raftAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.capabilities.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.timestamp = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.cpuCores = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.memoryBytes = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.diskBytes = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.rack = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.zone = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.region = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterWorkerRequest {
    return {
      grpcAddress: isSet(object.grpcAddress) ? globalThis.String(object.grpcAddress) : "",
      raftAddress: isSet(object.raftAddress) ? globalThis.String(object.raftAddress) : "",
      capabilities: globalThis.Array.isArray(object?.capabilities)
        ? object.capabilities.map((e: any) => globalThis.String(e))
        : [],
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "0",
      cpuCores: isSet(object.cpuCores) ? globalThis.Number(object.cpuCores) : 0,
      memoryBytes: isSet(object.memoryBytes) ? globalThis.String(object.memoryBytes) : "0",
      diskBytes: isSet(object.diskBytes) ? globalThis.String(object.diskBytes) : "0",
      rack: isSet(object.rack) ? globalThis.String(object.rack) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      region: isSet(object.region) ? globalThis.String(object.region) : "",
    };
  },

  toJSON(message: RegisterWorkerRequest): unknown {
    const obj: any = {};
    if (message.grpcAddress !== "") {
      obj.grpcAddress = message.grpcAddress;
    }
    if (message.raftAddress !== "") {
      obj.raftAddress = message.raftAddress;
    }
    if (message.capabilities?.length) {
      obj.capabilities = message.capabilities;
    }
    if (message.timestamp !== "0") {
      obj.timestamp = message.timestamp;
    }
    if (message.cpuCores !== 0) {
      obj.cpuCores = Math.round(message.cpuCores);
    }
    if (message.memoryBytes !== "0") {
      obj.memoryBytes = message.memoryBytes;
    }
    if (message.diskBytes !== "0") {
      obj.diskBytes = message.diskBytes;
    }
    if (message.rack !== "") {
      obj.rack = message.rack;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterWorkerRequest>, I>>(base?: I): RegisterWorkerRequest {
    return RegisterWorkerRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterWorkerRequest>, I>>(object: I): RegisterWorkerRequest {
    const message = createBaseRegisterWorkerRequest();
    message.grpcAddress = object.grpcAddress ?? "";
    message.raftAddress = object.raftAddress ?? "";
    message.capabilities = object.capabilities?.map((e) => e) || [];
    message.timestamp = object.timestamp ?? "0";
    message.cpuCores = object.cpuCores ?? 0;
    message.memoryBytes = object.memoryBytes ?? "0";
    message.diskBytes = object.diskBytes ?? "0";
    message.rack = object.rack ?? "";
    message.zone = object.zone ?? "";
    message.region = object.region ?? "";
    return message;
  },
};

function createBaseRegisterWorkerResponse(): RegisterWorkerResponse {
  return { workerId: "", success: false };
}

export const RegisterWorkerResponse: MessageFns<RegisterWorkerResponse> = {
  encode(message: RegisterWorkerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workerId !== "") {
      writer.uint32(10).string(message.workerId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterWorkerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterWorkerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterWorkerResponse {
    return {
      workerId: isSet(object.workerId) ? globalThis.String(object.workerId) : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
    };
  },

  toJSON(message: RegisterWorkerResponse): unknown {
    const obj: any = {};
    if (message.workerId !== "") {
      obj.workerId = message.workerId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterWorkerResponse>, I>>(base?: I): RegisterWorkerResponse {
    return RegisterWorkerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterWorkerResponse>, I>>(object: I): RegisterWorkerResponse {
    const message = createBaseRegisterWorkerResponse();
    message.workerId = object.workerId ?? "";
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseShardLeaderInfo(): ShardLeaderInfo {
  return { shardId: "0", leaderId: "0" };
}

export const ShardLeaderInfo: MessageFns<ShardLeaderInfo> = {
  encode(message: ShardLeaderInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shardId !== "0") {
      writer.uint32(8).uint64(message.shardId);
    }
    if (message.leaderId !== "0") {
      writer.uint32(16).uint64(message.leaderId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShardLeaderInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShardLeaderInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.shardId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.leaderId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShardLeaderInfo {
    return {
      shardId: isSet(object.shardId) ? globalThis.String(object.shardId) : "0",
      leaderId: isSet(object.leaderId) ? globalThis.String(object.leaderId) : "0",
    };
  },

  toJSON(message: ShardLeaderInfo): unknown {
    const obj: any = {};
    if (message.shardId !== "0") {
      obj.shardId = message.shardId;
    }
    if (message.leaderId !== "0") {
      obj.leaderId = message.leaderId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShardLeaderInfo>, I>>(base?: I): ShardLeaderInfo {
    return ShardLeaderInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShardLeaderInfo>, I>>(object: I): ShardLeaderInfo {
    const message = createBaseShardLeaderInfo();
    message.shardId = object.shardId ?? "0";
    message.leaderId = object.leaderId ?? "0";
    return message;
  },
};

function createBaseShardMetrics(): ShardMetrics {
  return { shardId: "0", queriesPerSecond: 0, vectorCount: "0", avgLatencyMs: 0 };
}

export const ShardMetrics: MessageFns<ShardMetrics> = {
  encode(message: ShardMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shardId !== "0") {
      writer.uint32(8).uint64(message.shardId);
    }
    if (message.queriesPerSecond !== 0) {
      writer.uint32(21).float(message.queriesPerSecond);
    }
    if (message.vectorCount !== "0") {
      writer.uint32(24).int64(message.vectorCount);
    }
    if (message.avgLatencyMs !== 0) {
      writer.uint32(37).float(message.avgLatencyMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShardMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShardMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.shardId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.queriesPerSecond = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.vectorCount = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.avgLatencyMs = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShardMetrics {
    return {
      shardId: isSet(object.shardId) ? globalThis.String(object.shardId) : "0",
      queriesPerSecond: isSet(object.queriesPerSecond) ? globalThis.Number(object.queriesPerSecond) : 0,
      vectorCount: isSet(object.vectorCount) ? globalThis.String(object.vectorCount) : "0",
      avgLatencyMs: isSet(object.avgLatencyMs) ? globalThis.Number(object.avgLatencyMs) : 0,
    };
  },

  toJSON(message: ShardMetrics): unknown {
    const obj: any = {};
    if (message.shardId !== "0") {
      obj.shardId = message.shardId;
    }
    if (message.queriesPerSecond !== 0) {
      obj.queriesPerSecond = message.queriesPerSecond;
    }
    if (message.vectorCount !== "0") {
      obj.vectorCount = message.vectorCount;
    }
    if (message.avgLatencyMs !== 0) {
      obj.avgLatencyMs = message.avgLatencyMs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShardMetrics>, I>>(base?: I): ShardMetrics {
    return ShardMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShardMetrics>, I>>(object: I): ShardMetrics {
    const message = createBaseShardMetrics();
    message.shardId = object.shardId ?? "0";
    message.queriesPerSecond = object.queriesPerSecond ?? 0;
    message.vectorCount = object.vectorCount ?? "0";
    message.avgLatencyMs = object.avgLatencyMs ?? 0;
    return message;
  },
};

function createBaseHeartbeatRequest(): HeartbeatRequest {
  return {
    workerId: "",
    timestamp: "0",
    vectorCount: "0",
    memoryBytes: "0",
    shardLeaderInfo: [],
    cpuUsagePercent: 0,
    memoryUsagePercent: 0,
    diskUsagePercent: 0,
    queriesPerSecond: 0,
    activeShards: "0",
    shardMetrics: [],
  };
}

export const HeartbeatRequest: MessageFns<HeartbeatRequest> = {
  encode(message: HeartbeatRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workerId !== "") {
      writer.uint32(10).string(message.workerId);
    }
    if (message.timestamp !== "0") {
      writer.uint32(16).int64(message.timestamp);
    }
    if (message.vectorCount !== "0") {
      writer.uint32(24).int64(message.vectorCount);
    }
    if (message.memoryBytes !== "0") {
      writer.uint32(32).int64(message.memoryBytes);
    }
    for (const v of message.shardLeaderInfo) {
      ShardLeaderInfo.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.cpuUsagePercent !== 0) {
      writer.uint32(53).float(message.cpuUsagePercent);
    }
    if (message.memoryUsagePercent !== 0) {
      writer.uint32(61).float(message.memoryUsagePercent);
    }
    if (message.diskUsagePercent !== 0) {
      writer.uint32(69).float(message.diskUsagePercent);
    }
    if (message.queriesPerSecond !== 0) {
      writer.uint32(77).float(message.queriesPerSecond);
    }
    if (message.activeShards !== "0") {
      writer.uint32(80).int64(message.activeShards);
    }
    for (const v of message.shardMetrics) {
      ShardMetrics.encode(v!, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeartbeatRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeatRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timestamp = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.vectorCount = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.memoryBytes = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.shardLeaderInfo.push(ShardLeaderInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.cpuUsagePercent = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.memoryUsagePercent = reader.float();
          continue;
        }
        case 8: {
          if (tag !== 69) {
            break;
          }

          message.diskUsagePercent = reader.float();
          continue;
        }
        case 9: {
          if (tag !== 77) {
            break;
          }

          message.queriesPerSecond = reader.float();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.activeShards = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.shardMetrics.push(ShardMetrics.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeartbeatRequest {
    return {
      workerId: isSet(object.workerId) ? globalThis.String(object.workerId) : "",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "0",
      vectorCount: isSet(object.vectorCount) ? globalThis.String(object.vectorCount) : "0",
      memoryBytes: isSet(object.memoryBytes) ? globalThis.String(object.memoryBytes) : "0",
      shardLeaderInfo: globalThis.Array.isArray(object?.shardLeaderInfo)
        ? object.shardLeaderInfo.map((e: any) => ShardLeaderInfo.fromJSON(e))
        : [],
      cpuUsagePercent: isSet(object.cpuUsagePercent) ? globalThis.Number(object.cpuUsagePercent) : 0,
      memoryUsagePercent: isSet(object.memoryUsagePercent) ? globalThis.Number(object.memoryUsagePercent) : 0,
      diskUsagePercent: isSet(object.diskUsagePercent) ? globalThis.Number(object.diskUsagePercent) : 0,
      queriesPerSecond: isSet(object.queriesPerSecond) ? globalThis.Number(object.queriesPerSecond) : 0,
      activeShards: isSet(object.activeShards) ? globalThis.String(object.activeShards) : "0",
      shardMetrics: globalThis.Array.isArray(object?.shardMetrics)
        ? object.shardMetrics.map((e: any) => ShardMetrics.fromJSON(e))
        : [],
    };
  },

  toJSON(message: HeartbeatRequest): unknown {
    const obj: any = {};
    if (message.workerId !== "") {
      obj.workerId = message.workerId;
    }
    if (message.timestamp !== "0") {
      obj.timestamp = message.timestamp;
    }
    if (message.vectorCount !== "0") {
      obj.vectorCount = message.vectorCount;
    }
    if (message.memoryBytes !== "0") {
      obj.memoryBytes = message.memoryBytes;
    }
    if (message.shardLeaderInfo?.length) {
      obj.shardLeaderInfo = message.shardLeaderInfo.map((e) => ShardLeaderInfo.toJSON(e));
    }
    if (message.cpuUsagePercent !== 0) {
      obj.cpuUsagePercent = message.cpuUsagePercent;
    }
    if (message.memoryUsagePercent !== 0) {
      obj.memoryUsagePercent = message.memoryUsagePercent;
    }
    if (message.diskUsagePercent !== 0) {
      obj.diskUsagePercent = message.diskUsagePercent;
    }
    if (message.queriesPerSecond !== 0) {
      obj.queriesPerSecond = message.queriesPerSecond;
    }
    if (message.activeShards !== "0") {
      obj.activeShards = message.activeShards;
    }
    if (message.shardMetrics?.length) {
      obj.shardMetrics = message.shardMetrics.map((e) => ShardMetrics.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeartbeatRequest>, I>>(base?: I): HeartbeatRequest {
    return HeartbeatRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeartbeatRequest>, I>>(object: I): HeartbeatRequest {
    const message = createBaseHeartbeatRequest();
    message.workerId = object.workerId ?? "";
    message.timestamp = object.timestamp ?? "0";
    message.vectorCount = object.vectorCount ?? "0";
    message.memoryBytes = object.memoryBytes ?? "0";
    message.shardLeaderInfo = object.shardLeaderInfo?.map((e) => ShardLeaderInfo.fromPartial(e)) || [];
    message.cpuUsagePercent = object.cpuUsagePercent ?? 0;
    message.memoryUsagePercent = object.memoryUsagePercent ?? 0;
    message.diskUsagePercent = object.diskUsagePercent ?? 0;
    message.queriesPerSecond = object.queriesPerSecond ?? 0;
    message.activeShards = object.activeShards ?? "0";
    message.shardMetrics = object.shardMetrics?.map((e) => ShardMetrics.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHeartbeatResponse(): HeartbeatResponse {
  return { ok: false, message: "" };
}

export const HeartbeatResponse: MessageFns<HeartbeatResponse> = {
  encode(message: HeartbeatResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ok !== false) {
      writer.uint32(8).bool(message.ok);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeartbeatResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeatResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.ok = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeartbeatResponse {
    return {
      ok: isSet(object.ok) ? globalThis.Boolean(object.ok) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: HeartbeatResponse): unknown {
    const obj: any = {};
    if (message.ok !== false) {
      obj.ok = message.ok;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeartbeatResponse>, I>>(base?: I): HeartbeatResponse {
    return HeartbeatResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeartbeatResponse>, I>>(object: I): HeartbeatResponse {
    const message = createBaseHeartbeatResponse();
    message.ok = object.ok ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseListWorkersRequest(): ListWorkersRequest {
  return {};
}

export const ListWorkersRequest: MessageFns<ListWorkersRequest> = {
  encode(_: ListWorkersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWorkersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListWorkersRequest {
    return {};
  },

  toJSON(_: ListWorkersRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListWorkersRequest>, I>>(base?: I): ListWorkersRequest {
    return ListWorkersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListWorkersRequest>, I>>(_: I): ListWorkersRequest {
    const message = createBaseListWorkersRequest();
    return message;
  },
};

function createBaseListWorkersResponse(): ListWorkersResponse {
  return { workers: [] };
}

export const ListWorkersResponse: MessageFns<ListWorkersResponse> = {
  encode(message: ListWorkersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.workers) {
      WorkerInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWorkersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workers.push(WorkerInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWorkersResponse {
    return {
      workers: globalThis.Array.isArray(object?.workers) ? object.workers.map((e: any) => WorkerInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListWorkersResponse): unknown {
    const obj: any = {};
    if (message.workers?.length) {
      obj.workers = message.workers.map((e) => WorkerInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListWorkersResponse>, I>>(base?: I): ListWorkersResponse {
    return ListWorkersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListWorkersResponse>, I>>(object: I): ListWorkersResponse {
    const message = createBaseListWorkersResponse();
    message.workers = object.workers?.map((e) => WorkerInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListWorkersForCollectionRequest(): ListWorkersForCollectionRequest {
  return { collection: "" };
}

export const ListWorkersForCollectionRequest: MessageFns<ListWorkersForCollectionRequest> = {
  encode(message: ListWorkersForCollectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.collection !== "") {
      writer.uint32(10).string(message.collection);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWorkersForCollectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkersForCollectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.collection = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWorkersForCollectionRequest {
    return { collection: isSet(object.collection) ? globalThis.String(object.collection) : "" };
  },

  toJSON(message: ListWorkersForCollectionRequest): unknown {
    const obj: any = {};
    if (message.collection !== "") {
      obj.collection = message.collection;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListWorkersForCollectionRequest>, I>>(base?: I): ListWorkersForCollectionRequest {
    return ListWorkersForCollectionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListWorkersForCollectionRequest>, I>>(
    object: I,
  ): ListWorkersForCollectionRequest {
    const message = createBaseListWorkersForCollectionRequest();
    message.collection = object.collection ?? "";
    return message;
  },
};

function createBaseListWorkersForCollectionResponse(): ListWorkersForCollectionResponse {
  return { grpcAddresses: [] };
}

export const ListWorkersForCollectionResponse: MessageFns<ListWorkersForCollectionResponse> = {
  encode(message: ListWorkersForCollectionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.grpcAddresses) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWorkersForCollectionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkersForCollectionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.grpcAddresses.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWorkersForCollectionResponse {
    return {
      grpcAddresses: globalThis.Array.isArray(object?.grpcAddresses)
        ? object.grpcAddresses.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListWorkersForCollectionResponse): unknown {
    const obj: any = {};
    if (message.grpcAddresses?.length) {
      obj.grpcAddresses = message.grpcAddresses;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListWorkersForCollectionResponse>, I>>(
    base?: I,
  ): ListWorkersForCollectionResponse {
    return ListWorkersForCollectionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListWorkersForCollectionResponse>, I>>(
    object: I,
  ): ListWorkersForCollectionResponse {
    const message = createBaseListWorkersForCollectionResponse();
    message.grpcAddresses = object.grpcAddresses?.map((e) => e) || [];
    return message;
  },
};

function createBaseWorkerInfo(): WorkerInfo {
  return {
    workerId: "",
    grpcAddress: "",
    raftAddress: "",
    collections: [],
    lastHeartbeat: "0",
    healthy: false,
    metadata: {},
  };
}

export const WorkerInfo: MessageFns<WorkerInfo> = {
  encode(message: WorkerInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workerId !== "") {
      writer.uint32(10).string(message.workerId);
    }
    if (message.grpcAddress !== "") {
      writer.uint32(18).string(message.grpcAddress);
    }
    if (message.raftAddress !== "") {
      writer.uint32(26).string(message.raftAddress);
    }
    for (const v of message.collections) {
      writer.uint32(34).string(v!);
    }
    if (message.lastHeartbeat !== "0") {
      writer.uint32(40).int64(message.lastHeartbeat);
    }
    if (message.healthy !== false) {
      writer.uint32(48).bool(message.healthy);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      WorkerInfo_MetadataEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkerInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.grpcAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.raftAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.collections.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.lastHeartbeat = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.healthy = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = WorkerInfo_MetadataEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.metadata[entry7.key] = entry7.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkerInfo {
    return {
      workerId: isSet(object.workerId) ? globalThis.String(object.workerId) : "",
      grpcAddress: isSet(object.grpcAddress) ? globalThis.String(object.grpcAddress) : "",
      raftAddress: isSet(object.raftAddress) ? globalThis.String(object.raftAddress) : "",
      collections: globalThis.Array.isArray(object?.collections)
        ? object.collections.map((e: any) => globalThis.String(e))
        : [],
      lastHeartbeat: isSet(object.lastHeartbeat) ? globalThis.String(object.lastHeartbeat) : "0",
      healthy: isSet(object.healthy) ? globalThis.Boolean(object.healthy) : false,
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: WorkerInfo): unknown {
    const obj: any = {};
    if (message.workerId !== "") {
      obj.workerId = message.workerId;
    }
    if (message.grpcAddress !== "") {
      obj.grpcAddress = message.grpcAddress;
    }
    if (message.raftAddress !== "") {
      obj.raftAddress = message.raftAddress;
    }
    if (message.collections?.length) {
      obj.collections = message.collections;
    }
    if (message.lastHeartbeat !== "0") {
      obj.lastHeartbeat = message.lastHeartbeat;
    }
    if (message.healthy !== false) {
      obj.healthy = message.healthy;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkerInfo>, I>>(base?: I): WorkerInfo {
    return WorkerInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkerInfo>, I>>(object: I): WorkerInfo {
    const message = createBaseWorkerInfo();
    message.workerId = object.workerId ?? "";
    message.grpcAddress = object.grpcAddress ?? "";
    message.raftAddress = object.raftAddress ?? "";
    message.collections = object.collections?.map((e) => e) || [];
    message.lastHeartbeat = object.lastHeartbeat ?? "0";
    message.healthy = object.healthy ?? false;
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseWorkerInfo_MetadataEntry(): WorkerInfo_MetadataEntry {
  return { key: "", value: "" };
}

export const WorkerInfo_MetadataEntry: MessageFns<WorkerInfo_MetadataEntry> = {
  encode(message: WorkerInfo_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkerInfo_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerInfo_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkerInfo_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: WorkerInfo_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkerInfo_MetadataEntry>, I>>(base?: I): WorkerInfo_MetadataEntry {
    return WorkerInfo_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkerInfo_MetadataEntry>, I>>(object: I): WorkerInfo_MetadataEntry {
    const message = createBaseWorkerInfo_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRebalanceRequest(): RebalanceRequest {
  return {};
}

export const RebalanceRequest: MessageFns<RebalanceRequest> = {
  encode(_: RebalanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RebalanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRebalanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RebalanceRequest {
    return {};
  },

  toJSON(_: RebalanceRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RebalanceRequest>, I>>(base?: I): RebalanceRequest {
    return RebalanceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RebalanceRequest>, I>>(_: I): RebalanceRequest {
    const message = createBaseRebalanceRequest();
    return message;
  },
};

function createBaseRebalanceResponse(): RebalanceResponse {
  return { started: false };
}

export const RebalanceResponse: MessageFns<RebalanceResponse> = {
  encode(message: RebalanceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.started !== false) {
      writer.uint32(8).bool(message.started);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RebalanceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRebalanceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.started = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RebalanceResponse {
    return { started: isSet(object.started) ? globalThis.Boolean(object.started) : false };
  },

  toJSON(message: RebalanceResponse): unknown {
    const obj: any = {};
    if (message.started !== false) {
      obj.started = message.started;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RebalanceResponse>, I>>(base?: I): RebalanceResponse {
    return RebalanceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RebalanceResponse>, I>>(object: I): RebalanceResponse {
    const message = createBaseRebalanceResponse();
    message.started = object.started ?? false;
    return message;
  },
};

function createBaseCreateCollectionRequest(): CreateCollectionRequest {
  return { name: "", dimension: 0, distance: "" };
}

export const CreateCollectionRequest: MessageFns<CreateCollectionRequest> = {
  encode(message: CreateCollectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.dimension !== 0) {
      writer.uint32(16).int32(message.dimension);
    }
    if (message.distance !== "") {
      writer.uint32(26).string(message.distance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCollectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCollectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.dimension = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.distance = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCollectionRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dimension: isSet(object.dimension) ? globalThis.Number(object.dimension) : 0,
      distance: isSet(object.distance) ? globalThis.String(object.distance) : "",
    };
  },

  toJSON(message: CreateCollectionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.dimension !== 0) {
      obj.dimension = Math.round(message.dimension);
    }
    if (message.distance !== "") {
      obj.distance = message.distance;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCollectionRequest>, I>>(base?: I): CreateCollectionRequest {
    return CreateCollectionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCollectionRequest>, I>>(object: I): CreateCollectionRequest {
    const message = createBaseCreateCollectionRequest();
    message.name = object.name ?? "";
    message.dimension = object.dimension ?? 0;
    message.distance = object.distance ?? "";
    return message;
  },
};

function createBaseCreateCollectionResponse(): CreateCollectionResponse {
  return { success: false };
}

export const CreateCollectionResponse: MessageFns<CreateCollectionResponse> = {
  encode(message: CreateCollectionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCollectionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCollectionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCollectionResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: CreateCollectionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCollectionResponse>, I>>(base?: I): CreateCollectionResponse {
    return CreateCollectionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCollectionResponse>, I>>(object: I): CreateCollectionResponse {
    const message = createBaseCreateCollectionResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseListCollectionsRequest(): ListCollectionsRequest {
  return {};
}

export const ListCollectionsRequest: MessageFns<ListCollectionsRequest> = {
  encode(_: ListCollectionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCollectionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCollectionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListCollectionsRequest {
    return {};
  },

  toJSON(_: ListCollectionsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListCollectionsRequest>, I>>(base?: I): ListCollectionsRequest {
    return ListCollectionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListCollectionsRequest>, I>>(_: I): ListCollectionsRequest {
    const message = createBaseListCollectionsRequest();
    return message;
  },
};

function createBaseListCollectionsResponse(): ListCollectionsResponse {
  return { collections: [] };
}

export const ListCollectionsResponse: MessageFns<ListCollectionsResponse> = {
  encode(message: ListCollectionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.collections) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCollectionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCollectionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.collections.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCollectionsResponse {
    return {
      collections: globalThis.Array.isArray(object?.collections)
        ? object.collections.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListCollectionsResponse): unknown {
    const obj: any = {};
    if (message.collections?.length) {
      obj.collections = message.collections;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListCollectionsResponse>, I>>(base?: I): ListCollectionsResponse {
    return ListCollectionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListCollectionsResponse>, I>>(object: I): ListCollectionsResponse {
    const message = createBaseListCollectionsResponse();
    message.collections = object.collections?.map((e) => e) || [];
    return message;
  },
};

function createBaseDeleteCollectionRequest(): DeleteCollectionRequest {
  return { name: "" };
}

export const DeleteCollectionRequest: MessageFns<DeleteCollectionRequest> = {
  encode(message: DeleteCollectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCollectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCollectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCollectionRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteCollectionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteCollectionRequest>, I>>(base?: I): DeleteCollectionRequest {
    return DeleteCollectionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteCollectionRequest>, I>>(object: I): DeleteCollectionRequest {
    const message = createBaseDeleteCollectionRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteCollectionResponse(): DeleteCollectionResponse {
  return { success: false };
}

export const DeleteCollectionResponse: MessageFns<DeleteCollectionResponse> = {
  encode(message: DeleteCollectionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCollectionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCollectionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCollectionResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: DeleteCollectionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteCollectionResponse>, I>>(base?: I): DeleteCollectionResponse {
    return DeleteCollectionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteCollectionResponse>, I>>(object: I): DeleteCollectionResponse {
    const message = createBaseDeleteCollectionResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseGetCollectionStatusRequest(): GetCollectionStatusRequest {
  return { name: "" };
}

export const GetCollectionStatusRequest: MessageFns<GetCollectionStatusRequest> = {
  encode(message: GetCollectionStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCollectionStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCollectionStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCollectionStatusRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetCollectionStatusRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCollectionStatusRequest>, I>>(base?: I): GetCollectionStatusRequest {
    return GetCollectionStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCollectionStatusRequest>, I>>(object: I): GetCollectionStatusRequest {
    const message = createBaseGetCollectionStatusRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetCollectionStatusResponse(): GetCollectionStatusResponse {
  return { name: "", dimension: 0, distance: "", shards: [] };
}

export const GetCollectionStatusResponse: MessageFns<GetCollectionStatusResponse> = {
  encode(message: GetCollectionStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.dimension !== 0) {
      writer.uint32(16).int32(message.dimension);
    }
    if (message.distance !== "") {
      writer.uint32(26).string(message.distance);
    }
    for (const v of message.shards) {
      ShardStatus.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCollectionStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCollectionStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.dimension = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.distance = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.shards.push(ShardStatus.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCollectionStatusResponse {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dimension: isSet(object.dimension) ? globalThis.Number(object.dimension) : 0,
      distance: isSet(object.distance) ? globalThis.String(object.distance) : "",
      shards: globalThis.Array.isArray(object?.shards) ? object.shards.map((e: any) => ShardStatus.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetCollectionStatusResponse): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.dimension !== 0) {
      obj.dimension = Math.round(message.dimension);
    }
    if (message.distance !== "") {
      obj.distance = message.distance;
    }
    if (message.shards?.length) {
      obj.shards = message.shards.map((e) => ShardStatus.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCollectionStatusResponse>, I>>(base?: I): GetCollectionStatusResponse {
    return GetCollectionStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCollectionStatusResponse>, I>>(object: I): GetCollectionStatusResponse {
    const message = createBaseGetCollectionStatusResponse();
    message.name = object.name ?? "";
    message.dimension = object.dimension ?? 0;
    message.distance = object.distance ?? "";
    message.shards = object.shards?.map((e) => ShardStatus.fromPartial(e)) || [];
    return message;
  },
};

function createBaseShardStatus(): ShardStatus {
  return { shardId: 0, replicas: [], leaderId: "0", ready: false };
}

export const ShardStatus: MessageFns<ShardStatus> = {
  encode(message: ShardStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shardId !== 0) {
      writer.uint32(8).uint32(message.shardId);
    }
    writer.uint32(18).fork();
    for (const v of message.replicas) {
      writer.uint64(v);
    }
    writer.join();
    if (message.leaderId !== "0") {
      writer.uint32(24).uint64(message.leaderId);
    }
    if (message.ready !== false) {
      writer.uint32(32).bool(message.ready);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShardStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShardStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.shardId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.replicas.push(reader.uint64().toString());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.replicas.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.leaderId = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ready = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShardStatus {
    return {
      shardId: isSet(object.shardId) ? globalThis.Number(object.shardId) : 0,
      replicas: globalThis.Array.isArray(object?.replicas) ? object.replicas.map((e: any) => globalThis.String(e)) : [],
      leaderId: isSet(object.leaderId) ? globalThis.String(object.leaderId) : "0",
      ready: isSet(object.ready) ? globalThis.Boolean(object.ready) : false,
    };
  },

  toJSON(message: ShardStatus): unknown {
    const obj: any = {};
    if (message.shardId !== 0) {
      obj.shardId = Math.round(message.shardId);
    }
    if (message.replicas?.length) {
      obj.replicas = message.replicas;
    }
    if (message.leaderId !== "0") {
      obj.leaderId = message.leaderId;
    }
    if (message.ready !== false) {
      obj.ready = message.ready;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShardStatus>, I>>(base?: I): ShardStatus {
    return ShardStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShardStatus>, I>>(object: I): ShardStatus {
    const message = createBaseShardStatus();
    message.shardId = object.shardId ?? 0;
    message.replicas = object.replicas?.map((e) => e) || [];
    message.leaderId = object.leaderId ?? "0";
    message.ready = object.ready ?? false;
    return message;
  },
};

export type PlacementServiceService = typeof PlacementServiceService;
export const PlacementServiceService = {
  /** Get worker address for a collection + optional vector ID (for consistent hashing) */
  getWorker: {
    path: "/vectron.placementdriver.v1.PlacementService/GetWorker",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetWorkerRequest): Buffer => Buffer.from(GetWorkerRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetWorkerRequest => GetWorkerRequest.decode(value),
    responseSerialize: (value: GetWorkerResponse): Buffer => Buffer.from(GetWorkerResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetWorkerResponse => GetWorkerResponse.decode(value),
  },
  /** Worker registers itself on startup */
  registerWorker: {
    path: "/vectron.placementdriver.v1.PlacementService/RegisterWorker",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RegisterWorkerRequest): Buffer =>
      Buffer.from(RegisterWorkerRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RegisterWorkerRequest => RegisterWorkerRequest.decode(value),
    responseSerialize: (value: RegisterWorkerResponse): Buffer =>
      Buffer.from(RegisterWorkerResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RegisterWorkerResponse => RegisterWorkerResponse.decode(value),
  },
  /** Worker sends heartbeat (every 5s) */
  heartbeat: {
    path: "/vectron.placementdriver.v1.PlacementService/Heartbeat",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: HeartbeatRequest): Buffer => Buffer.from(HeartbeatRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): HeartbeatRequest => HeartbeatRequest.decode(value),
    responseSerialize: (value: HeartbeatResponse): Buffer => Buffer.from(HeartbeatResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): HeartbeatResponse => HeartbeatResponse.decode(value),
  },
  /** List all workers (for monitoring) */
  listWorkers: {
    path: "/vectron.placementdriver.v1.PlacementService/ListWorkers",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListWorkersRequest): Buffer => Buffer.from(ListWorkersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListWorkersRequest => ListWorkersRequest.decode(value),
    responseSerialize: (value: ListWorkersResponse): Buffer => Buffer.from(ListWorkersResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListWorkersResponse => ListWorkersResponse.decode(value),
  },
  listWorkersForCollection: {
    path: "/vectron.placementdriver.v1.PlacementService/ListWorkersForCollection",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListWorkersForCollectionRequest): Buffer =>
      Buffer.from(ListWorkersForCollectionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListWorkersForCollectionRequest =>
      ListWorkersForCollectionRequest.decode(value),
    responseSerialize: (value: ListWorkersForCollectionResponse): Buffer =>
      Buffer.from(ListWorkersForCollectionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListWorkersForCollectionResponse =>
      ListWorkersForCollectionResponse.decode(value),
  },
  /** Admin: force rebalance (future) */
  rebalance: {
    path: "/vectron.placementdriver.v1.PlacementService/Rebalance",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RebalanceRequest): Buffer => Buffer.from(RebalanceRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RebalanceRequest => RebalanceRequest.decode(value),
    responseSerialize: (value: RebalanceResponse): Buffer => Buffer.from(RebalanceResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RebalanceResponse => RebalanceResponse.decode(value),
  },
  /** Collection management */
  createCollection: {
    path: "/vectron.placementdriver.v1.PlacementService/CreateCollection",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateCollectionRequest): Buffer =>
      Buffer.from(CreateCollectionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateCollectionRequest => CreateCollectionRequest.decode(value),
    responseSerialize: (value: CreateCollectionResponse): Buffer =>
      Buffer.from(CreateCollectionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CreateCollectionResponse => CreateCollectionResponse.decode(value),
  },
  listCollections: {
    path: "/vectron.placementdriver.v1.PlacementService/ListCollections",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListCollectionsRequest): Buffer =>
      Buffer.from(ListCollectionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListCollectionsRequest => ListCollectionsRequest.decode(value),
    responseSerialize: (value: ListCollectionsResponse): Buffer =>
      Buffer.from(ListCollectionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListCollectionsResponse => ListCollectionsResponse.decode(value),
  },
  deleteCollection: {
    path: "/vectron.placementdriver.v1.PlacementService/DeleteCollection",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteCollectionRequest): Buffer =>
      Buffer.from(DeleteCollectionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteCollectionRequest => DeleteCollectionRequest.decode(value),
    responseSerialize: (value: DeleteCollectionResponse): Buffer =>
      Buffer.from(DeleteCollectionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteCollectionResponse => DeleteCollectionResponse.decode(value),
  },
  getCollectionStatus: {
    path: "/vectron.placementdriver.v1.PlacementService/GetCollectionStatus",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetCollectionStatusRequest): Buffer =>
      Buffer.from(GetCollectionStatusRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetCollectionStatusRequest => GetCollectionStatusRequest.decode(value),
    responseSerialize: (value: GetCollectionStatusResponse): Buffer =>
      Buffer.from(GetCollectionStatusResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetCollectionStatusResponse => GetCollectionStatusResponse.decode(value),
  },
  getLeader: {
    path: "/vectron.placementdriver.v1.PlacementService/GetLeader",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetLeaderRequest): Buffer => Buffer.from(GetLeaderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetLeaderRequest => GetLeaderRequest.decode(value),
    responseSerialize: (value: GetLeaderResponse): Buffer => Buffer.from(GetLeaderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetLeaderResponse => GetLeaderResponse.decode(value),
  },
} as const;

export interface PlacementServiceServer extends UntypedServiceImplementation {
  /** Get worker address for a collection + optional vector ID (for consistent hashing) */
  getWorker: handleUnaryCall<GetWorkerRequest, GetWorkerResponse>;
  /** Worker registers itself on startup */
  registerWorker: handleUnaryCall<RegisterWorkerRequest, RegisterWorkerResponse>;
  /** Worker sends heartbeat (every 5s) */
  heartbeat: handleUnaryCall<HeartbeatRequest, HeartbeatResponse>;
  /** List all workers (for monitoring) */
  listWorkers: handleUnaryCall<ListWorkersRequest, ListWorkersResponse>;
  listWorkersForCollection: handleUnaryCall<ListWorkersForCollectionRequest, ListWorkersForCollectionResponse>;
  /** Admin: force rebalance (future) */
  rebalance: handleUnaryCall<RebalanceRequest, RebalanceResponse>;
  /** Collection management */
  createCollection: handleUnaryCall<CreateCollectionRequest, CreateCollectionResponse>;
  listCollections: handleUnaryCall<ListCollectionsRequest, ListCollectionsResponse>;
  deleteCollection: handleUnaryCall<DeleteCollectionRequest, DeleteCollectionResponse>;
  getCollectionStatus: handleUnaryCall<GetCollectionStatusRequest, GetCollectionStatusResponse>;
  getLeader: handleUnaryCall<GetLeaderRequest, GetLeaderResponse>;
}

export interface PlacementServiceClient extends Client {
  /** Get worker address for a collection + optional vector ID (for consistent hashing) */
  getWorker(
    request: GetWorkerRequest,
    callback: (error: ServiceError | null, response: GetWorkerResponse) => void,
  ): ClientUnaryCall;
  getWorker(
    request: GetWorkerRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetWorkerResponse) => void,
  ): ClientUnaryCall;
  getWorker(
    request: GetWorkerRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetWorkerResponse) => void,
  ): ClientUnaryCall;
  /** Worker registers itself on startup */
  registerWorker(
    request: RegisterWorkerRequest,
    callback: (error: ServiceError | null, response: RegisterWorkerResponse) => void,
  ): ClientUnaryCall;
  registerWorker(
    request: RegisterWorkerRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RegisterWorkerResponse) => void,
  ): ClientUnaryCall;
  registerWorker(
    request: RegisterWorkerRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RegisterWorkerResponse) => void,
  ): ClientUnaryCall;
  /** Worker sends heartbeat (every 5s) */
  heartbeat(
    request: HeartbeatRequest,
    callback: (error: ServiceError | null, response: HeartbeatResponse) => void,
  ): ClientUnaryCall;
  heartbeat(
    request: HeartbeatRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: HeartbeatResponse) => void,
  ): ClientUnaryCall;
  heartbeat(
    request: HeartbeatRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: HeartbeatResponse) => void,
  ): ClientUnaryCall;
  /** List all workers (for monitoring) */
  listWorkers(
    request: ListWorkersRequest,
    callback: (error: ServiceError | null, response: ListWorkersResponse) => void,
  ): ClientUnaryCall;
  listWorkers(
    request: ListWorkersRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListWorkersResponse) => void,
  ): ClientUnaryCall;
  listWorkers(
    request: ListWorkersRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListWorkersResponse) => void,
  ): ClientUnaryCall;
  listWorkersForCollection(
    request: ListWorkersForCollectionRequest,
    callback: (error: ServiceError | null, response: ListWorkersForCollectionResponse) => void,
  ): ClientUnaryCall;
  listWorkersForCollection(
    request: ListWorkersForCollectionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListWorkersForCollectionResponse) => void,
  ): ClientUnaryCall;
  listWorkersForCollection(
    request: ListWorkersForCollectionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListWorkersForCollectionResponse) => void,
  ): ClientUnaryCall;
  /** Admin: force rebalance (future) */
  rebalance(
    request: RebalanceRequest,
    callback: (error: ServiceError | null, response: RebalanceResponse) => void,
  ): ClientUnaryCall;
  rebalance(
    request: RebalanceRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RebalanceResponse) => void,
  ): ClientUnaryCall;
  rebalance(
    request: RebalanceRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RebalanceResponse) => void,
  ): ClientUnaryCall;
  /** Collection management */
  createCollection(
    request: CreateCollectionRequest,
    callback: (error: ServiceError | null, response: CreateCollectionResponse) => void,
  ): ClientUnaryCall;
  createCollection(
    request: CreateCollectionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateCollectionResponse) => void,
  ): ClientUnaryCall;
  createCollection(
    request: CreateCollectionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateCollectionResponse) => void,
  ): ClientUnaryCall;
  listCollections(
    request: ListCollectionsRequest,
    callback: (error: ServiceError | null, response: ListCollectionsResponse) => void,
  ): ClientUnaryCall;
  listCollections(
    request: ListCollectionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListCollectionsResponse) => void,
  ): ClientUnaryCall;
  listCollections(
    request: ListCollectionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListCollectionsResponse) => void,
  ): ClientUnaryCall;
  deleteCollection(
    request: DeleteCollectionRequest,
    callback: (error: ServiceError | null, response: DeleteCollectionResponse) => void,
  ): ClientUnaryCall;
  deleteCollection(
    request: DeleteCollectionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeleteCollectionResponse) => void,
  ): ClientUnaryCall;
  deleteCollection(
    request: DeleteCollectionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeleteCollectionResponse) => void,
  ): ClientUnaryCall;
  getCollectionStatus(
    request: GetCollectionStatusRequest,
    callback: (error: ServiceError | null, response: GetCollectionStatusResponse) => void,
  ): ClientUnaryCall;
  getCollectionStatus(
    request: GetCollectionStatusRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetCollectionStatusResponse) => void,
  ): ClientUnaryCall;
  getCollectionStatus(
    request: GetCollectionStatusRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetCollectionStatusResponse) => void,
  ): ClientUnaryCall;
  getLeader(
    request: GetLeaderRequest,
    callback: (error: ServiceError | null, response: GetLeaderResponse) => void,
  ): ClientUnaryCall;
  getLeader(
    request: GetLeaderRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetLeaderResponse) => void,
  ): ClientUnaryCall;
  getLeader(
    request: GetLeaderRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetLeaderResponse) => void,
  ): ClientUnaryCall;
}

export const PlacementServiceClient = makeGenericClientConstructor(
  PlacementServiceService,
  "vectron.placementdriver.v1.PlacementService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): PlacementServiceClient;
  service: typeof PlacementServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
