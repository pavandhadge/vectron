// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.10.1
//   protoc               v3.19.6
// source: apigateway/apigateway.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Plan, planFromJSON, planToJSON, UserProfile } from "../auth/auth";

export const protobufPackage = "vectron.v1";

export interface CreateCollectionRequest {
  name: string;
  dimension: number;
  /** "cosine", "euclidean", "dot" */
  distance: string;
}

export interface CreateCollectionResponse {
  success: boolean;
}

export interface DeleteCollectionRequest {
  name: string;
}

export interface DeleteCollectionResponse {
  success: boolean;
}

export interface UpsertRequest {
  collection: string;
  points: Point[];
}

export interface UpsertResponse {
  upserted: number;
}

export interface SearchRequest {
  collection: string;
  vector: number[];
  /**
   * proto3 has no native defaults â€” this sets an OpenAPI (Swagger) default
   * so the generated OpenAPI spec will show top_k default = 10.
   */
  topK: number;
  /** Optional natural language query for reranking purposes. */
  query: string;
  /**
   * Optional per-request timeout budget for search fan-out (milliseconds).
   * If set, slow worker responses may be skipped and partial results returned.
   */
  timeoutMs: number;
}

export interface SearchResponse {
  results: SearchResult[];
}

export interface SearchResult {
  id: string;
  score: number;
  payload: { [key: string]: string };
}

export interface SearchResult_PayloadEntry {
  key: string;
  value: string;
}

export interface GetRequest {
  collection: string;
  id: string;
}

export interface GetResponse {
  point: Point | undefined;
}

export interface DeleteRequest {
  collection: string;
  id: string;
}

export interface DeleteResponse {
}

export interface ListCollectionsRequest {
}

export interface ListCollectionsResponse {
  collections: string[];
}

export interface GetCollectionStatusRequest {
  name: string;
}

export interface GetCollectionStatusResponse {
  name: string;
  dimension: number;
  distance: string;
  shards: ShardStatus[];
}

export interface ShardStatus {
  shardId: number;
  replicas: string[];
  leaderId: string;
  ready: boolean;
}

export interface Point {
  id: string;
  vector: number[];
  payload: { [key: string]: string };
}

export interface Point_PayloadEntry {
  key: string;
  value: string;
}

export interface UpdateUserProfileRequest {
  plan: Plan;
}

export interface UpdateUserProfileResponse {
  user: UserProfile | undefined;
}

export interface SubmitFeedbackRequest {
  collection: string;
  /** Original search query (optional) */
  query: string;
  /** IDs of search results */
  resultIds: string[];
  /** Feedback for each result */
  feedbackItems: FeedbackItem[];
  /** Additional context (user_id, session_id, etc.) */
  context: { [key: string]: string };
}

export interface SubmitFeedbackRequest_ContextEntry {
  key: string;
  value: string;
}

export interface FeedbackItem {
  /** ID of the result being rated */
  resultId: string;
  /** 1-5 scale (1=not relevant, 5=highly relevant) */
  relevanceScore: number;
  /** Whether user clicked on this result */
  clicked: boolean;
  /** Position in the returned results (0-based) */
  position: number;
  /** Optional user comment */
  comment: string;
}

export interface SubmitFeedbackResponse {
  success: boolean;
  /** Unique identifier for this feedback session */
  feedbackId: string;
}

function createBaseCreateCollectionRequest(): CreateCollectionRequest {
  return { name: "", dimension: 0, distance: "" };
}

export const CreateCollectionRequest: MessageFns<CreateCollectionRequest> = {
  encode(message: CreateCollectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.dimension !== 0) {
      writer.uint32(16).int32(message.dimension);
    }
    if (message.distance !== "") {
      writer.uint32(26).string(message.distance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCollectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCollectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.dimension = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.distance = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCollectionRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dimension: isSet(object.dimension) ? globalThis.Number(object.dimension) : 0,
      distance: isSet(object.distance) ? globalThis.String(object.distance) : "",
    };
  },

  toJSON(message: CreateCollectionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.dimension !== 0) {
      obj.dimension = Math.round(message.dimension);
    }
    if (message.distance !== "") {
      obj.distance = message.distance;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCollectionRequest>, I>>(base?: I): CreateCollectionRequest {
    return CreateCollectionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCollectionRequest>, I>>(object: I): CreateCollectionRequest {
    const message = createBaseCreateCollectionRequest();
    message.name = object.name ?? "";
    message.dimension = object.dimension ?? 0;
    message.distance = object.distance ?? "";
    return message;
  },
};

function createBaseCreateCollectionResponse(): CreateCollectionResponse {
  return { success: false };
}

export const CreateCollectionResponse: MessageFns<CreateCollectionResponse> = {
  encode(message: CreateCollectionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCollectionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCollectionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCollectionResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: CreateCollectionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCollectionResponse>, I>>(base?: I): CreateCollectionResponse {
    return CreateCollectionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCollectionResponse>, I>>(object: I): CreateCollectionResponse {
    const message = createBaseCreateCollectionResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseDeleteCollectionRequest(): DeleteCollectionRequest {
  return { name: "" };
}

export const DeleteCollectionRequest: MessageFns<DeleteCollectionRequest> = {
  encode(message: DeleteCollectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCollectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCollectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCollectionRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteCollectionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteCollectionRequest>, I>>(base?: I): DeleteCollectionRequest {
    return DeleteCollectionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteCollectionRequest>, I>>(object: I): DeleteCollectionRequest {
    const message = createBaseDeleteCollectionRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteCollectionResponse(): DeleteCollectionResponse {
  return { success: false };
}

export const DeleteCollectionResponse: MessageFns<DeleteCollectionResponse> = {
  encode(message: DeleteCollectionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCollectionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCollectionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCollectionResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: DeleteCollectionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteCollectionResponse>, I>>(base?: I): DeleteCollectionResponse {
    return DeleteCollectionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteCollectionResponse>, I>>(object: I): DeleteCollectionResponse {
    const message = createBaseDeleteCollectionResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseUpsertRequest(): UpsertRequest {
  return { collection: "", points: [] };
}

export const UpsertRequest: MessageFns<UpsertRequest> = {
  encode(message: UpsertRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.collection !== "") {
      writer.uint32(10).string(message.collection);
    }
    for (const v of message.points) {
      Point.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.collection = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.points.push(Point.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpsertRequest {
    return {
      collection: isSet(object.collection) ? globalThis.String(object.collection) : "",
      points: globalThis.Array.isArray(object?.points) ? object.points.map((e: any) => Point.fromJSON(e)) : [],
    };
  },

  toJSON(message: UpsertRequest): unknown {
    const obj: any = {};
    if (message.collection !== "") {
      obj.collection = message.collection;
    }
    if (message.points?.length) {
      obj.points = message.points.map((e) => Point.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertRequest>, I>>(base?: I): UpsertRequest {
    return UpsertRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertRequest>, I>>(object: I): UpsertRequest {
    const message = createBaseUpsertRequest();
    message.collection = object.collection ?? "";
    message.points = object.points?.map((e) => Point.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpsertResponse(): UpsertResponse {
  return { upserted: 0 };
}

export const UpsertResponse: MessageFns<UpsertResponse> = {
  encode(message: UpsertResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.upserted !== 0) {
      writer.uint32(8).int32(message.upserted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.upserted = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpsertResponse {
    return { upserted: isSet(object.upserted) ? globalThis.Number(object.upserted) : 0 };
  },

  toJSON(message: UpsertResponse): unknown {
    const obj: any = {};
    if (message.upserted !== 0) {
      obj.upserted = Math.round(message.upserted);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertResponse>, I>>(base?: I): UpsertResponse {
    return UpsertResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertResponse>, I>>(object: I): UpsertResponse {
    const message = createBaseUpsertResponse();
    message.upserted = object.upserted ?? 0;
    return message;
  },
};

function createBaseSearchRequest(): SearchRequest {
  return { collection: "", vector: [], topK: 0, query: "", timeoutMs: 0 };
}

export const SearchRequest: MessageFns<SearchRequest> = {
  encode(message: SearchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.collection !== "") {
      writer.uint32(10).string(message.collection);
    }
    for (const v of message.vector) {
      writer.uint32(21).float(v!);
    }
    if (message.topK !== 0) {
      writer.uint32(24).uint32(message.topK);
    }
    if (message.query !== "") {
      writer.uint32(34).string(message.query);
    }
    if (message.timeoutMs !== 0) {
      writer.uint32(40).uint32(message.timeoutMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.collection = reader.string();
          continue;
        }
        case 2: {
          if (tag === 21) {
            message.vector.push(reader.float());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.vector.push(reader.float());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.topK = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.query = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.timeoutMs = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest {
    return {
      collection: isSet(object.collection) ? globalThis.String(object.collection) : "",
      vector: globalThis.Array.isArray(object?.vector) ? object.vector.map((e: any) => globalThis.Number(e)) : [],
      topK: isSet(object.topK) ? globalThis.Number(object.topK) : 0,
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      timeoutMs: isSet(object.timeoutMs) ? globalThis.Number(object.timeoutMs) : 0,
    };
  },

  toJSON(message: SearchRequest): unknown {
    const obj: any = {};
    if (message.collection !== "") {
      obj.collection = message.collection;
    }
    if (message.vector?.length) {
      obj.vector = message.vector;
    }
    if (message.topK !== 0) {
      obj.topK = Math.round(message.topK);
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.timeoutMs !== 0) {
      obj.timeoutMs = Math.round(message.timeoutMs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchRequest>, I>>(base?: I): SearchRequest {
    return SearchRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchRequest>, I>>(object: I): SearchRequest {
    const message = createBaseSearchRequest();
    message.collection = object.collection ?? "";
    message.vector = object.vector?.map((e) => e) || [];
    message.topK = object.topK ?? 0;
    message.query = object.query ?? "";
    message.timeoutMs = object.timeoutMs ?? 0;
    return message;
  },
};

function createBaseSearchResponse(): SearchResponse {
  return { results: [] };
}

export const SearchResponse: MessageFns<SearchResponse> = {
  encode(message: SearchResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      SearchResult.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.results.push(SearchResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => SearchResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => SearchResult.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchResponse>, I>>(base?: I): SearchResponse {
    return SearchResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchResponse>, I>>(object: I): SearchResponse {
    const message = createBaseSearchResponse();
    message.results = object.results?.map((e) => SearchResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchResult(): SearchResult {
  return { id: "", score: 0, payload: {} };
}

export const SearchResult: MessageFns<SearchResult> = {
  encode(message: SearchResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.score !== 0) {
      writer.uint32(21).float(message.score);
    }
    globalThis.Object.entries(message.payload).forEach(([key, value]: [string, string]) => {
      SearchResult_PayloadEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.score = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = SearchResult_PayloadEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.payload[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResult {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      payload: isObject(object.payload)
        ? (globalThis.Object.entries(object.payload) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: SearchResult): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.score !== 0) {
      obj.score = message.score;
    }
    if (message.payload) {
      const entries = globalThis.Object.entries(message.payload) as [string, string][];
      if (entries.length > 0) {
        obj.payload = {};
        entries.forEach(([k, v]) => {
          obj.payload[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchResult>, I>>(base?: I): SearchResult {
    return SearchResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchResult>, I>>(object: I): SearchResult {
    const message = createBaseSearchResult();
    message.id = object.id ?? "";
    message.score = object.score ?? 0;
    message.payload = (globalThis.Object.entries(object.payload ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseSearchResult_PayloadEntry(): SearchResult_PayloadEntry {
  return { key: "", value: "" };
}

export const SearchResult_PayloadEntry: MessageFns<SearchResult_PayloadEntry> = {
  encode(message: SearchResult_PayloadEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResult_PayloadEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResult_PayloadEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResult_PayloadEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SearchResult_PayloadEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchResult_PayloadEntry>, I>>(base?: I): SearchResult_PayloadEntry {
    return SearchResult_PayloadEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchResult_PayloadEntry>, I>>(object: I): SearchResult_PayloadEntry {
    const message = createBaseSearchResult_PayloadEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetRequest(): GetRequest {
  return { collection: "", id: "" };
}

export const GetRequest: MessageFns<GetRequest> = {
  encode(message: GetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.collection !== "") {
      writer.uint32(10).string(message.collection);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.collection = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRequest {
    return {
      collection: isSet(object.collection) ? globalThis.String(object.collection) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: GetRequest): unknown {
    const obj: any = {};
    if (message.collection !== "") {
      obj.collection = message.collection;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRequest>, I>>(base?: I): GetRequest {
    return GetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRequest>, I>>(object: I): GetRequest {
    const message = createBaseGetRequest();
    message.collection = object.collection ?? "";
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseGetResponse(): GetResponse {
  return { point: undefined };
}

export const GetResponse: MessageFns<GetResponse> = {
  encode(message: GetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.point !== undefined) {
      Point.encode(message.point, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.point = Point.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetResponse {
    return { point: isSet(object.point) ? Point.fromJSON(object.point) : undefined };
  },

  toJSON(message: GetResponse): unknown {
    const obj: any = {};
    if (message.point !== undefined) {
      obj.point = Point.toJSON(message.point);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetResponse>, I>>(base?: I): GetResponse {
    return GetResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetResponse>, I>>(object: I): GetResponse {
    const message = createBaseGetResponse();
    message.point = (object.point !== undefined && object.point !== null) ? Point.fromPartial(object.point) : undefined;
    return message;
  },
};

function createBaseDeleteRequest(): DeleteRequest {
  return { collection: "", id: "" };
}

export const DeleteRequest: MessageFns<DeleteRequest> = {
  encode(message: DeleteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.collection !== "") {
      writer.uint32(10).string(message.collection);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.collection = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteRequest {
    return {
      collection: isSet(object.collection) ? globalThis.String(object.collection) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: DeleteRequest): unknown {
    const obj: any = {};
    if (message.collection !== "") {
      obj.collection = message.collection;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteRequest>, I>>(base?: I): DeleteRequest {
    return DeleteRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteRequest>, I>>(object: I): DeleteRequest {
    const message = createBaseDeleteRequest();
    message.collection = object.collection ?? "";
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseDeleteResponse(): DeleteResponse {
  return {};
}

export const DeleteResponse: MessageFns<DeleteResponse> = {
  encode(_: DeleteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteResponse {
    return {};
  },

  toJSON(_: DeleteResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteResponse>, I>>(base?: I): DeleteResponse {
    return DeleteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteResponse>, I>>(_: I): DeleteResponse {
    const message = createBaseDeleteResponse();
    return message;
  },
};

function createBaseListCollectionsRequest(): ListCollectionsRequest {
  return {};
}

export const ListCollectionsRequest: MessageFns<ListCollectionsRequest> = {
  encode(_: ListCollectionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCollectionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCollectionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListCollectionsRequest {
    return {};
  },

  toJSON(_: ListCollectionsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListCollectionsRequest>, I>>(base?: I): ListCollectionsRequest {
    return ListCollectionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListCollectionsRequest>, I>>(_: I): ListCollectionsRequest {
    const message = createBaseListCollectionsRequest();
    return message;
  },
};

function createBaseListCollectionsResponse(): ListCollectionsResponse {
  return { collections: [] };
}

export const ListCollectionsResponse: MessageFns<ListCollectionsResponse> = {
  encode(message: ListCollectionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.collections) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCollectionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCollectionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.collections.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCollectionsResponse {
    return {
      collections: globalThis.Array.isArray(object?.collections)
        ? object.collections.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListCollectionsResponse): unknown {
    const obj: any = {};
    if (message.collections?.length) {
      obj.collections = message.collections;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListCollectionsResponse>, I>>(base?: I): ListCollectionsResponse {
    return ListCollectionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListCollectionsResponse>, I>>(object: I): ListCollectionsResponse {
    const message = createBaseListCollectionsResponse();
    message.collections = object.collections?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetCollectionStatusRequest(): GetCollectionStatusRequest {
  return { name: "" };
}

export const GetCollectionStatusRequest: MessageFns<GetCollectionStatusRequest> = {
  encode(message: GetCollectionStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCollectionStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCollectionStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCollectionStatusRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetCollectionStatusRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCollectionStatusRequest>, I>>(base?: I): GetCollectionStatusRequest {
    return GetCollectionStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCollectionStatusRequest>, I>>(object: I): GetCollectionStatusRequest {
    const message = createBaseGetCollectionStatusRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetCollectionStatusResponse(): GetCollectionStatusResponse {
  return { name: "", dimension: 0, distance: "", shards: [] };
}

export const GetCollectionStatusResponse: MessageFns<GetCollectionStatusResponse> = {
  encode(message: GetCollectionStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.dimension !== 0) {
      writer.uint32(16).int32(message.dimension);
    }
    if (message.distance !== "") {
      writer.uint32(26).string(message.distance);
    }
    for (const v of message.shards) {
      ShardStatus.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCollectionStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCollectionStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.dimension = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.distance = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.shards.push(ShardStatus.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCollectionStatusResponse {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dimension: isSet(object.dimension) ? globalThis.Number(object.dimension) : 0,
      distance: isSet(object.distance) ? globalThis.String(object.distance) : "",
      shards: globalThis.Array.isArray(object?.shards) ? object.shards.map((e: any) => ShardStatus.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetCollectionStatusResponse): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.dimension !== 0) {
      obj.dimension = Math.round(message.dimension);
    }
    if (message.distance !== "") {
      obj.distance = message.distance;
    }
    if (message.shards?.length) {
      obj.shards = message.shards.map((e) => ShardStatus.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCollectionStatusResponse>, I>>(base?: I): GetCollectionStatusResponse {
    return GetCollectionStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCollectionStatusResponse>, I>>(object: I): GetCollectionStatusResponse {
    const message = createBaseGetCollectionStatusResponse();
    message.name = object.name ?? "";
    message.dimension = object.dimension ?? 0;
    message.distance = object.distance ?? "";
    message.shards = object.shards?.map((e) => ShardStatus.fromPartial(e)) || [];
    return message;
  },
};

function createBaseShardStatus(): ShardStatus {
  return { shardId: 0, replicas: [], leaderId: "0", ready: false };
}

export const ShardStatus: MessageFns<ShardStatus> = {
  encode(message: ShardStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shardId !== 0) {
      writer.uint32(8).uint32(message.shardId);
    }
    writer.uint32(18).fork();
    for (const v of message.replicas) {
      writer.uint64(v);
    }
    writer.join();
    if (message.leaderId !== "0") {
      writer.uint32(24).uint64(message.leaderId);
    }
    if (message.ready !== false) {
      writer.uint32(32).bool(message.ready);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShardStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShardStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.shardId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.replicas.push(reader.uint64().toString());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.replicas.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.leaderId = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ready = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShardStatus {
    return {
      shardId: isSet(object.shardId) ? globalThis.Number(object.shardId) : 0,
      replicas: globalThis.Array.isArray(object?.replicas) ? object.replicas.map((e: any) => globalThis.String(e)) : [],
      leaderId: isSet(object.leaderId) ? globalThis.String(object.leaderId) : "0",
      ready: isSet(object.ready) ? globalThis.Boolean(object.ready) : false,
    };
  },

  toJSON(message: ShardStatus): unknown {
    const obj: any = {};
    if (message.shardId !== 0) {
      obj.shardId = Math.round(message.shardId);
    }
    if (message.replicas?.length) {
      obj.replicas = message.replicas;
    }
    if (message.leaderId !== "0") {
      obj.leaderId = message.leaderId;
    }
    if (message.ready !== false) {
      obj.ready = message.ready;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShardStatus>, I>>(base?: I): ShardStatus {
    return ShardStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShardStatus>, I>>(object: I): ShardStatus {
    const message = createBaseShardStatus();
    message.shardId = object.shardId ?? 0;
    message.replicas = object.replicas?.map((e) => e) || [];
    message.leaderId = object.leaderId ?? "0";
    message.ready = object.ready ?? false;
    return message;
  },
};

function createBasePoint(): Point {
  return { id: "", vector: [], payload: {} };
}

export const Point: MessageFns<Point> = {
  encode(message: Point, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    writer.uint32(18).fork();
    for (const v of message.vector) {
      writer.float(v);
    }
    writer.join();
    globalThis.Object.entries(message.payload).forEach(([key, value]: [string, string]) => {
      Point_PayloadEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Point {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag === 21) {
            message.vector.push(reader.float());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.vector.push(reader.float());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = Point_PayloadEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.payload[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Point {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      vector: globalThis.Array.isArray(object?.vector) ? object.vector.map((e: any) => globalThis.Number(e)) : [],
      payload: isObject(object.payload)
        ? (globalThis.Object.entries(object.payload) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: Point): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.vector?.length) {
      obj.vector = message.vector;
    }
    if (message.payload) {
      const entries = globalThis.Object.entries(message.payload) as [string, string][];
      if (entries.length > 0) {
        obj.payload = {};
        entries.forEach(([k, v]) => {
          obj.payload[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Point>, I>>(base?: I): Point {
    return Point.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Point>, I>>(object: I): Point {
    const message = createBasePoint();
    message.id = object.id ?? "";
    message.vector = object.vector?.map((e) => e) || [];
    message.payload = (globalThis.Object.entries(object.payload ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBasePoint_PayloadEntry(): Point_PayloadEntry {
  return { key: "", value: "" };
}

export const Point_PayloadEntry: MessageFns<Point_PayloadEntry> = {
  encode(message: Point_PayloadEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Point_PayloadEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePoint_PayloadEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Point_PayloadEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Point_PayloadEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Point_PayloadEntry>, I>>(base?: I): Point_PayloadEntry {
    return Point_PayloadEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Point_PayloadEntry>, I>>(object: I): Point_PayloadEntry {
    const message = createBasePoint_PayloadEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseUpdateUserProfileRequest(): UpdateUserProfileRequest {
  return { plan: 0 };
}

export const UpdateUserProfileRequest: MessageFns<UpdateUserProfileRequest> = {
  encode(message: UpdateUserProfileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.plan !== 0) {
      writer.uint32(8).int32(message.plan);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateUserProfileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserProfileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.plan = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserProfileRequest {
    return { plan: isSet(object.plan) ? planFromJSON(object.plan) : 0 };
  },

  toJSON(message: UpdateUserProfileRequest): unknown {
    const obj: any = {};
    if (message.plan !== 0) {
      obj.plan = planToJSON(message.plan);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserProfileRequest>, I>>(base?: I): UpdateUserProfileRequest {
    return UpdateUserProfileRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUserProfileRequest>, I>>(object: I): UpdateUserProfileRequest {
    const message = createBaseUpdateUserProfileRequest();
    message.plan = object.plan ?? 0;
    return message;
  },
};

function createBaseUpdateUserProfileResponse(): UpdateUserProfileResponse {
  return { user: undefined };
}

export const UpdateUserProfileResponse: MessageFns<UpdateUserProfileResponse> = {
  encode(message: UpdateUserProfileResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      UserProfile.encode(message.user, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateUserProfileResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserProfileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = UserProfile.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserProfileResponse {
    return { user: isSet(object.user) ? UserProfile.fromJSON(object.user) : undefined };
  },

  toJSON(message: UpdateUserProfileResponse): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = UserProfile.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserProfileResponse>, I>>(base?: I): UpdateUserProfileResponse {
    return UpdateUserProfileResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUserProfileResponse>, I>>(object: I): UpdateUserProfileResponse {
    const message = createBaseUpdateUserProfileResponse();
    message.user = (object.user !== undefined && object.user !== null)
      ? UserProfile.fromPartial(object.user)
      : undefined;
    return message;
  },
};

function createBaseSubmitFeedbackRequest(): SubmitFeedbackRequest {
  return { collection: "", query: "", resultIds: [], feedbackItems: [], context: {} };
}

export const SubmitFeedbackRequest: MessageFns<SubmitFeedbackRequest> = {
  encode(message: SubmitFeedbackRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.collection !== "") {
      writer.uint32(10).string(message.collection);
    }
    if (message.query !== "") {
      writer.uint32(18).string(message.query);
    }
    for (const v of message.resultIds) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.feedbackItems) {
      FeedbackItem.encode(v!, writer.uint32(34).fork()).join();
    }
    globalThis.Object.entries(message.context).forEach(([key, value]: [string, string]) => {
      SubmitFeedbackRequest_ContextEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitFeedbackRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitFeedbackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.collection = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.query = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.resultIds.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.feedbackItems.push(FeedbackItem.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = SubmitFeedbackRequest_ContextEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.context[entry5.key] = entry5.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitFeedbackRequest {
    return {
      collection: isSet(object.collection) ? globalThis.String(object.collection) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      resultIds: globalThis.Array.isArray(object?.resultIds)
        ? object.resultIds.map((e: any) => globalThis.String(e))
        : [],
      feedbackItems: globalThis.Array.isArray(object?.feedbackItems)
        ? object.feedbackItems.map((e: any) => FeedbackItem.fromJSON(e))
        : [],
      context: isObject(object.context)
        ? (globalThis.Object.entries(object.context) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: SubmitFeedbackRequest): unknown {
    const obj: any = {};
    if (message.collection !== "") {
      obj.collection = message.collection;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.resultIds?.length) {
      obj.resultIds = message.resultIds;
    }
    if (message.feedbackItems?.length) {
      obj.feedbackItems = message.feedbackItems.map((e) => FeedbackItem.toJSON(e));
    }
    if (message.context) {
      const entries = globalThis.Object.entries(message.context) as [string, string][];
      if (entries.length > 0) {
        obj.context = {};
        entries.forEach(([k, v]) => {
          obj.context[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitFeedbackRequest>, I>>(base?: I): SubmitFeedbackRequest {
    return SubmitFeedbackRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitFeedbackRequest>, I>>(object: I): SubmitFeedbackRequest {
    const message = createBaseSubmitFeedbackRequest();
    message.collection = object.collection ?? "";
    message.query = object.query ?? "";
    message.resultIds = object.resultIds?.map((e) => e) || [];
    message.feedbackItems = object.feedbackItems?.map((e) => FeedbackItem.fromPartial(e)) || [];
    message.context = (globalThis.Object.entries(object.context ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseSubmitFeedbackRequest_ContextEntry(): SubmitFeedbackRequest_ContextEntry {
  return { key: "", value: "" };
}

export const SubmitFeedbackRequest_ContextEntry: MessageFns<SubmitFeedbackRequest_ContextEntry> = {
  encode(message: SubmitFeedbackRequest_ContextEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitFeedbackRequest_ContextEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitFeedbackRequest_ContextEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitFeedbackRequest_ContextEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SubmitFeedbackRequest_ContextEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitFeedbackRequest_ContextEntry>, I>>(
    base?: I,
  ): SubmitFeedbackRequest_ContextEntry {
    return SubmitFeedbackRequest_ContextEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitFeedbackRequest_ContextEntry>, I>>(
    object: I,
  ): SubmitFeedbackRequest_ContextEntry {
    const message = createBaseSubmitFeedbackRequest_ContextEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseFeedbackItem(): FeedbackItem {
  return { resultId: "", relevanceScore: 0, clicked: false, position: 0, comment: "" };
}

export const FeedbackItem: MessageFns<FeedbackItem> = {
  encode(message: FeedbackItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resultId !== "") {
      writer.uint32(10).string(message.resultId);
    }
    if (message.relevanceScore !== 0) {
      writer.uint32(16).int32(message.relevanceScore);
    }
    if (message.clicked !== false) {
      writer.uint32(24).bool(message.clicked);
    }
    if (message.position !== 0) {
      writer.uint32(32).int32(message.position);
    }
    if (message.comment !== "") {
      writer.uint32(42).string(message.comment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeedbackItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeedbackItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resultId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.relevanceScore = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.clicked = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.position = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.comment = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeedbackItem {
    return {
      resultId: isSet(object.resultId) ? globalThis.String(object.resultId) : "",
      relevanceScore: isSet(object.relevanceScore) ? globalThis.Number(object.relevanceScore) : 0,
      clicked: isSet(object.clicked) ? globalThis.Boolean(object.clicked) : false,
      position: isSet(object.position) ? globalThis.Number(object.position) : 0,
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
    };
  },

  toJSON(message: FeedbackItem): unknown {
    const obj: any = {};
    if (message.resultId !== "") {
      obj.resultId = message.resultId;
    }
    if (message.relevanceScore !== 0) {
      obj.relevanceScore = Math.round(message.relevanceScore);
    }
    if (message.clicked !== false) {
      obj.clicked = message.clicked;
    }
    if (message.position !== 0) {
      obj.position = Math.round(message.position);
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeedbackItem>, I>>(base?: I): FeedbackItem {
    return FeedbackItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeedbackItem>, I>>(object: I): FeedbackItem {
    const message = createBaseFeedbackItem();
    message.resultId = object.resultId ?? "";
    message.relevanceScore = object.relevanceScore ?? 0;
    message.clicked = object.clicked ?? false;
    message.position = object.position ?? 0;
    message.comment = object.comment ?? "";
    return message;
  },
};

function createBaseSubmitFeedbackResponse(): SubmitFeedbackResponse {
  return { success: false, feedbackId: "" };
}

export const SubmitFeedbackResponse: MessageFns<SubmitFeedbackResponse> = {
  encode(message: SubmitFeedbackResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.feedbackId !== "") {
      writer.uint32(18).string(message.feedbackId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitFeedbackResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitFeedbackResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.feedbackId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitFeedbackResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      feedbackId: isSet(object.feedbackId) ? globalThis.String(object.feedbackId) : "",
    };
  },

  toJSON(message: SubmitFeedbackResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.feedbackId !== "") {
      obj.feedbackId = message.feedbackId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitFeedbackResponse>, I>>(base?: I): SubmitFeedbackResponse {
    return SubmitFeedbackResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitFeedbackResponse>, I>>(object: I): SubmitFeedbackResponse {
    const message = createBaseSubmitFeedbackResponse();
    message.success = object.success ?? false;
    message.feedbackId = object.feedbackId ?? "";
    return message;
  },
};

export type VectronServiceService = typeof VectronServiceService;
export const VectronServiceService = {
  /** Create a new collection */
  createCollection: {
    path: "/vectron.v1.VectronService/CreateCollection",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateCollectionRequest): Buffer =>
      Buffer.from(CreateCollectionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateCollectionRequest => CreateCollectionRequest.decode(value),
    responseSerialize: (value: CreateCollectionResponse): Buffer =>
      Buffer.from(CreateCollectionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CreateCollectionResponse => CreateCollectionResponse.decode(value),
  },
  /** Delete a collection and all its data */
  deleteCollection: {
    path: "/vectron.v1.VectronService/DeleteCollection",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteCollectionRequest): Buffer =>
      Buffer.from(DeleteCollectionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteCollectionRequest => DeleteCollectionRequest.decode(value),
    responseSerialize: (value: DeleteCollectionResponse): Buffer =>
      Buffer.from(DeleteCollectionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteCollectionResponse => DeleteCollectionResponse.decode(value),
  },
  /** Upsert vectors */
  upsert: {
    path: "/vectron.v1.VectronService/Upsert",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpsertRequest): Buffer => Buffer.from(UpsertRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpsertRequest => UpsertRequest.decode(value),
    responseSerialize: (value: UpsertResponse): Buffer => Buffer.from(UpsertResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): UpsertResponse => UpsertResponse.decode(value),
  },
  /** Search vectors */
  search: {
    path: "/vectron.v1.VectronService/Search",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SearchRequest): Buffer => Buffer.from(SearchRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SearchRequest => SearchRequest.decode(value),
    responseSerialize: (value: SearchResponse): Buffer => Buffer.from(SearchResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SearchResponse => SearchResponse.decode(value),
  },
  /** Get point by ID */
  get: {
    path: "/vectron.v1.VectronService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetRequest): Buffer => Buffer.from(GetRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetRequest => GetRequest.decode(value),
    responseSerialize: (value: GetResponse): Buffer => Buffer.from(GetResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetResponse => GetResponse.decode(value),
  },
  /** Delete point by ID */
  delete: {
    path: "/vectron.v1.VectronService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteRequest): Buffer => Buffer.from(DeleteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteRequest => DeleteRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  /** List all collections */
  listCollections: {
    path: "/vectron.v1.VectronService/ListCollections",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListCollectionsRequest): Buffer =>
      Buffer.from(ListCollectionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListCollectionsRequest => ListCollectionsRequest.decode(value),
    responseSerialize: (value: ListCollectionsResponse): Buffer =>
      Buffer.from(ListCollectionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListCollectionsResponse => ListCollectionsResponse.decode(value),
  },
  /** Get collection status */
  getCollectionStatus: {
    path: "/vectron.v1.VectronService/GetCollectionStatus",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetCollectionStatusRequest): Buffer =>
      Buffer.from(GetCollectionStatusRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetCollectionStatusRequest => GetCollectionStatusRequest.decode(value),
    responseSerialize: (value: GetCollectionStatusResponse): Buffer =>
      Buffer.from(GetCollectionStatusResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetCollectionStatusResponse => GetCollectionStatusResponse.decode(value),
  },
  /** Update user profile */
  updateUserProfile: {
    path: "/vectron.v1.VectronService/UpdateUserProfile",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateUserProfileRequest): Buffer =>
      Buffer.from(UpdateUserProfileRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateUserProfileRequest => UpdateUserProfileRequest.decode(value),
    responseSerialize: (value: UpdateUserProfileResponse): Buffer =>
      Buffer.from(UpdateUserProfileResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): UpdateUserProfileResponse => UpdateUserProfileResponse.decode(value),
  },
  /** Submit search feedback */
  submitFeedback: {
    path: "/vectron.v1.VectronService/SubmitFeedback",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SubmitFeedbackRequest): Buffer =>
      Buffer.from(SubmitFeedbackRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SubmitFeedbackRequest => SubmitFeedbackRequest.decode(value),
    responseSerialize: (value: SubmitFeedbackResponse): Buffer =>
      Buffer.from(SubmitFeedbackResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SubmitFeedbackResponse => SubmitFeedbackResponse.decode(value),
  },
} as const;

export interface VectronServiceServer extends UntypedServiceImplementation {
  /** Create a new collection */
  createCollection: handleUnaryCall<CreateCollectionRequest, CreateCollectionResponse>;
  /** Delete a collection and all its data */
  deleteCollection: handleUnaryCall<DeleteCollectionRequest, DeleteCollectionResponse>;
  /** Upsert vectors */
  upsert: handleUnaryCall<UpsertRequest, UpsertResponse>;
  /** Search vectors */
  search: handleUnaryCall<SearchRequest, SearchResponse>;
  /** Get point by ID */
  get: handleUnaryCall<GetRequest, GetResponse>;
  /** Delete point by ID */
  delete: handleUnaryCall<DeleteRequest, DeleteResponse>;
  /** List all collections */
  listCollections: handleUnaryCall<ListCollectionsRequest, ListCollectionsResponse>;
  /** Get collection status */
  getCollectionStatus: handleUnaryCall<GetCollectionStatusRequest, GetCollectionStatusResponse>;
  /** Update user profile */
  updateUserProfile: handleUnaryCall<UpdateUserProfileRequest, UpdateUserProfileResponse>;
  /** Submit search feedback */
  submitFeedback: handleUnaryCall<SubmitFeedbackRequest, SubmitFeedbackResponse>;
}

export interface VectronServiceClient extends Client {
  /** Create a new collection */
  createCollection(
    request: CreateCollectionRequest,
    callback: (error: ServiceError | null, response: CreateCollectionResponse) => void,
  ): ClientUnaryCall;
  createCollection(
    request: CreateCollectionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateCollectionResponse) => void,
  ): ClientUnaryCall;
  createCollection(
    request: CreateCollectionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateCollectionResponse) => void,
  ): ClientUnaryCall;
  /** Delete a collection and all its data */
  deleteCollection(
    request: DeleteCollectionRequest,
    callback: (error: ServiceError | null, response: DeleteCollectionResponse) => void,
  ): ClientUnaryCall;
  deleteCollection(
    request: DeleteCollectionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeleteCollectionResponse) => void,
  ): ClientUnaryCall;
  deleteCollection(
    request: DeleteCollectionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeleteCollectionResponse) => void,
  ): ClientUnaryCall;
  /** Upsert vectors */
  upsert(
    request: UpsertRequest,
    callback: (error: ServiceError | null, response: UpsertResponse) => void,
  ): ClientUnaryCall;
  upsert(
    request: UpsertRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpsertResponse) => void,
  ): ClientUnaryCall;
  upsert(
    request: UpsertRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpsertResponse) => void,
  ): ClientUnaryCall;
  /** Search vectors */
  search(
    request: SearchRequest,
    callback: (error: ServiceError | null, response: SearchResponse) => void,
  ): ClientUnaryCall;
  search(
    request: SearchRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SearchResponse) => void,
  ): ClientUnaryCall;
  search(
    request: SearchRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SearchResponse) => void,
  ): ClientUnaryCall;
  /** Get point by ID */
  get(request: GetRequest, callback: (error: ServiceError | null, response: GetResponse) => void): ClientUnaryCall;
  get(
    request: GetRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetResponse) => void,
  ): ClientUnaryCall;
  get(
    request: GetRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetResponse) => void,
  ): ClientUnaryCall;
  /** Delete point by ID */
  delete(
    request: DeleteRequest,
    callback: (error: ServiceError | null, response: DeleteResponse) => void,
  ): ClientUnaryCall;
  delete(
    request: DeleteRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeleteResponse) => void,
  ): ClientUnaryCall;
  delete(
    request: DeleteRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeleteResponse) => void,
  ): ClientUnaryCall;
  /** List all collections */
  listCollections(
    request: ListCollectionsRequest,
    callback: (error: ServiceError | null, response: ListCollectionsResponse) => void,
  ): ClientUnaryCall;
  listCollections(
    request: ListCollectionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListCollectionsResponse) => void,
  ): ClientUnaryCall;
  listCollections(
    request: ListCollectionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListCollectionsResponse) => void,
  ): ClientUnaryCall;
  /** Get collection status */
  getCollectionStatus(
    request: GetCollectionStatusRequest,
    callback: (error: ServiceError | null, response: GetCollectionStatusResponse) => void,
  ): ClientUnaryCall;
  getCollectionStatus(
    request: GetCollectionStatusRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetCollectionStatusResponse) => void,
  ): ClientUnaryCall;
  getCollectionStatus(
    request: GetCollectionStatusRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetCollectionStatusResponse) => void,
  ): ClientUnaryCall;
  /** Update user profile */
  updateUserProfile(
    request: UpdateUserProfileRequest,
    callback: (error: ServiceError | null, response: UpdateUserProfileResponse) => void,
  ): ClientUnaryCall;
  updateUserProfile(
    request: UpdateUserProfileRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpdateUserProfileResponse) => void,
  ): ClientUnaryCall;
  updateUserProfile(
    request: UpdateUserProfileRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpdateUserProfileResponse) => void,
  ): ClientUnaryCall;
  /** Submit search feedback */
  submitFeedback(
    request: SubmitFeedbackRequest,
    callback: (error: ServiceError | null, response: SubmitFeedbackResponse) => void,
  ): ClientUnaryCall;
  submitFeedback(
    request: SubmitFeedbackRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SubmitFeedbackResponse) => void,
  ): ClientUnaryCall;
  submitFeedback(
    request: SubmitFeedbackRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SubmitFeedbackResponse) => void,
  ): ClientUnaryCall;
}

export const VectronServiceClient = makeGenericClientConstructor(
  VectronServiceService,
  "vectron.v1.VectronService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): VectronServiceClient;
  service: typeof VectronServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
