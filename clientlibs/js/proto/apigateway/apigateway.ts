// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v3.19.6
// source: proto/apigateway/apigateway.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "vectron.v1";

export interface CreateCollectionRequest {
  name: string;
  dimension: number;
  distance: string;
}

export interface CreateCollectionResponse {
  success: boolean;
}

export interface UpsertRequest {
  collection: string;
  points: Point[];
}

export interface UpsertResponse {
  upserted: number;
}

export interface SearchRequest {
  collection: string;
  vector: number[];
  topK: number;
}

export interface SearchResponse {
  results: SearchResult[];
}

export interface SearchResult {
  id: string;
  score: number;
  payload: { [key: string]: string };
}

export interface SearchResult_PayloadEntry {
  key: string;
  value: string;
}

export interface GetRequest {
  collection: string;
  id: string;
}

export interface GetResponse {
  point: Point | undefined;
}

export interface DeleteRequest {
  collection: string;
  id: string;
}

export interface DeleteResponse {
}

export interface ListCollectionsRequest {
}

export interface ListCollectionsResponse {
  collections: string[];
}

export interface Point {
  id: string;
  vector: number[];
  payload: { [key: string]: string };
}

export interface Point_PayloadEntry {
  key: string;
  value: string;
}

function createBaseCreateCollectionRequest(): CreateCollectionRequest {
  return { name: "", dimension: 0, distance: "" };
}

export const CreateCollectionRequest: MessageFns<CreateCollectionRequest> = {
  encode(message: CreateCollectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.dimension !== 0) {
      writer.uint32(16).int32(message.dimension);
    }
    if (message.distance !== "") {
      writer.uint32(26).string(message.distance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCollectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCollectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.dimension = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.distance = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCollectionRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dimension: isSet(object.dimension) ? globalThis.Number(object.dimension) : 0,
      distance: isSet(object.distance) ? globalThis.String(object.distance) : "",
    };
  },

  toJSON(message: CreateCollectionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.dimension !== 0) {
      obj.dimension = Math.round(message.dimension);
    }
    if (message.distance !== "") {
      obj.distance = message.distance;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCollectionRequest>, I>>(base?: I): CreateCollectionRequest {
    return CreateCollectionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCollectionRequest>, I>>(object: I): CreateCollectionRequest {
    const message = createBaseCreateCollectionRequest();
    message.name = object.name ?? "";
    message.dimension = object.dimension ?? 0;
    message.distance = object.distance ?? "";
    return message;
  },
};

function createBaseCreateCollectionResponse(): CreateCollectionResponse {
  return { success: false };
}

export const CreateCollectionResponse: MessageFns<CreateCollectionResponse> = {
  encode(message: CreateCollectionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCollectionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCollectionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCollectionResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: CreateCollectionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCollectionResponse>, I>>(base?: I): CreateCollectionResponse {
    return CreateCollectionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCollectionResponse>, I>>(object: I): CreateCollectionResponse {
    const message = createBaseCreateCollectionResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseUpsertRequest(): UpsertRequest {
  return { collection: "", points: [] };
}

export const UpsertRequest: MessageFns<UpsertRequest> = {
  encode(message: UpsertRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.collection !== "") {
      writer.uint32(10).string(message.collection);
    }
    for (const v of message.points) {
      Point.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.collection = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.points.push(Point.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpsertRequest {
    return {
      collection: isSet(object.collection) ? globalThis.String(object.collection) : "",
      points: globalThis.Array.isArray(object?.points) ? object.points.map((e: any) => Point.fromJSON(e)) : [],
    };
  },

  toJSON(message: UpsertRequest): unknown {
    const obj: any = {};
    if (message.collection !== "") {
      obj.collection = message.collection;
    }
    if (message.points?.length) {
      obj.points = message.points.map((e) => Point.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertRequest>, I>>(base?: I): UpsertRequest {
    return UpsertRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertRequest>, I>>(object: I): UpsertRequest {
    const message = createBaseUpsertRequest();
    message.collection = object.collection ?? "";
    message.points = object.points?.map((e) => Point.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpsertResponse(): UpsertResponse {
  return { upserted: 0 };
}

export const UpsertResponse: MessageFns<UpsertResponse> = {
  encode(message: UpsertResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.upserted !== 0) {
      writer.uint32(8).int32(message.upserted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.upserted = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpsertResponse {
    return { upserted: isSet(object.upserted) ? globalThis.Number(object.upserted) : 0 };
  },

  toJSON(message: UpsertResponse): unknown {
    const obj: any = {};
    if (message.upserted !== 0) {
      obj.upserted = Math.round(message.upserted);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertResponse>, I>>(base?: I): UpsertResponse {
    return UpsertResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertResponse>, I>>(object: I): UpsertResponse {
    const message = createBaseUpsertResponse();
    message.upserted = object.upserted ?? 0;
    return message;
  },
};

function createBaseSearchRequest(): SearchRequest {
  return { collection: "", vector: [], topK: 0 };
}

export const SearchRequest: MessageFns<SearchRequest> = {
  encode(message: SearchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.collection !== "") {
      writer.uint32(10).string(message.collection);
    }
    for (const v of message.vector) {
      writer.uint32(21).float(v!);
    }
    if (message.topK !== 0) {
      writer.uint32(24).uint32(message.topK);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.collection = reader.string();
          continue;
        }
        case 2: {
          if (tag === 21) {
            message.vector.push(reader.float());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.vector.push(reader.float());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.topK = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest {
    return {
      collection: isSet(object.collection) ? globalThis.String(object.collection) : "",
      vector: globalThis.Array.isArray(object?.vector) ? object.vector.map((e: any) => globalThis.Number(e)) : [],
      topK: isSet(object.topK) ? globalThis.Number(object.topK) : 0,
    };
  },

  toJSON(message: SearchRequest): unknown {
    const obj: any = {};
    if (message.collection !== "") {
      obj.collection = message.collection;
    }
    if (message.vector?.length) {
      obj.vector = message.vector;
    }
    if (message.topK !== 0) {
      obj.topK = Math.round(message.topK);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchRequest>, I>>(base?: I): SearchRequest {
    return SearchRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchRequest>, I>>(object: I): SearchRequest {
    const message = createBaseSearchRequest();
    message.collection = object.collection ?? "";
    message.vector = object.vector?.map((e) => e) || [];
    message.topK = object.topK ?? 0;
    return message;
  },
};

function createBaseSearchResponse(): SearchResponse {
  return { results: [] };
}

export const SearchResponse: MessageFns<SearchResponse> = {
  encode(message: SearchResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      SearchResult.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.results.push(SearchResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => SearchResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => SearchResult.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchResponse>, I>>(base?: I): SearchResponse {
    return SearchResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchResponse>, I>>(object: I): SearchResponse {
    const message = createBaseSearchResponse();
    message.results = object.results?.map((e) => SearchResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchResult(): SearchResult {
  return { id: "", score: 0, payload: {} };
}

export const SearchResult: MessageFns<SearchResult> = {
  encode(message: SearchResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.score !== 0) {
      writer.uint32(21).float(message.score);
    }
    Object.entries(message.payload).forEach(([key, value]) => {
      SearchResult_PayloadEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.score = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = SearchResult_PayloadEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.payload[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResult {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      payload: isObject(object.payload)
        ? Object.entries(object.payload).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SearchResult): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.score !== 0) {
      obj.score = message.score;
    }
    if (message.payload) {
      const entries = Object.entries(message.payload);
      if (entries.length > 0) {
        obj.payload = {};
        entries.forEach(([k, v]) => {
          obj.payload[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchResult>, I>>(base?: I): SearchResult {
    return SearchResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchResult>, I>>(object: I): SearchResult {
    const message = createBaseSearchResult();
    message.id = object.id ?? "";
    message.score = object.score ?? 0;
    message.payload = Object.entries(object.payload ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseSearchResult_PayloadEntry(): SearchResult_PayloadEntry {
  return { key: "", value: "" };
}

export const SearchResult_PayloadEntry: MessageFns<SearchResult_PayloadEntry> = {
  encode(message: SearchResult_PayloadEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResult_PayloadEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResult_PayloadEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResult_PayloadEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SearchResult_PayloadEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchResult_PayloadEntry>, I>>(base?: I): SearchResult_PayloadEntry {
    return SearchResult_PayloadEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchResult_PayloadEntry>, I>>(object: I): SearchResult_PayloadEntry {
    const message = createBaseSearchResult_PayloadEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetRequest(): GetRequest {
  return { collection: "", id: "" };
}

export const GetRequest: MessageFns<GetRequest> = {
  encode(message: GetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.collection !== "") {
      writer.uint32(10).string(message.collection);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.collection = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRequest {
    return {
      collection: isSet(object.collection) ? globalThis.String(object.collection) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: GetRequest): unknown {
    const obj: any = {};
    if (message.collection !== "") {
      obj.collection = message.collection;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRequest>, I>>(base?: I): GetRequest {
    return GetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRequest>, I>>(object: I): GetRequest {
    const message = createBaseGetRequest();
    message.collection = object.collection ?? "";
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseGetResponse(): GetResponse {
  return { point: undefined };
}

export const GetResponse: MessageFns<GetResponse> = {
  encode(message: GetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.point !== undefined) {
      Point.encode(message.point, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.point = Point.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetResponse {
    return { point: isSet(object.point) ? Point.fromJSON(object.point) : undefined };
  },

  toJSON(message: GetResponse): unknown {
    const obj: any = {};
    if (message.point !== undefined) {
      obj.point = Point.toJSON(message.point);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetResponse>, I>>(base?: I): GetResponse {
    return GetResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetResponse>, I>>(object: I): GetResponse {
    const message = createBaseGetResponse();
    message.point = (object.point !== undefined && object.point !== null) ? Point.fromPartial(object.point) : undefined;
    return message;
  },
};

function createBaseDeleteRequest(): DeleteRequest {
  return { collection: "", id: "" };
}

export const DeleteRequest: MessageFns<DeleteRequest> = {
  encode(message: DeleteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.collection !== "") {
      writer.uint32(10).string(message.collection);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.collection = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteRequest {
    return {
      collection: isSet(object.collection) ? globalThis.String(object.collection) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: DeleteRequest): unknown {
    const obj: any = {};
    if (message.collection !== "") {
      obj.collection = message.collection;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteRequest>, I>>(base?: I): DeleteRequest {
    return DeleteRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteRequest>, I>>(object: I): DeleteRequest {
    const message = createBaseDeleteRequest();
    message.collection = object.collection ?? "";
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseDeleteResponse(): DeleteResponse {
  return {};
}

export const DeleteResponse: MessageFns<DeleteResponse> = {
  encode(_: DeleteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteResponse {
    return {};
  },

  toJSON(_: DeleteResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteResponse>, I>>(base?: I): DeleteResponse {
    return DeleteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteResponse>, I>>(_: I): DeleteResponse {
    const message = createBaseDeleteResponse();
    return message;
  },
};

function createBaseListCollectionsRequest(): ListCollectionsRequest {
  return {};
}

export const ListCollectionsRequest: MessageFns<ListCollectionsRequest> = {
  encode(_: ListCollectionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCollectionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCollectionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListCollectionsRequest {
    return {};
  },

  toJSON(_: ListCollectionsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListCollectionsRequest>, I>>(base?: I): ListCollectionsRequest {
    return ListCollectionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListCollectionsRequest>, I>>(_: I): ListCollectionsRequest {
    const message = createBaseListCollectionsRequest();
    return message;
  },
};

function createBaseListCollectionsResponse(): ListCollectionsResponse {
  return { collections: [] };
}

export const ListCollectionsResponse: MessageFns<ListCollectionsResponse> = {
  encode(message: ListCollectionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.collections) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCollectionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCollectionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.collections.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCollectionsResponse {
    return {
      collections: globalThis.Array.isArray(object?.collections)
        ? object.collections.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListCollectionsResponse): unknown {
    const obj: any = {};
    if (message.collections?.length) {
      obj.collections = message.collections;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListCollectionsResponse>, I>>(base?: I): ListCollectionsResponse {
    return ListCollectionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListCollectionsResponse>, I>>(object: I): ListCollectionsResponse {
    const message = createBaseListCollectionsResponse();
    message.collections = object.collections?.map((e) => e) || [];
    return message;
  },
};

function createBasePoint(): Point {
  return { id: "", vector: [], payload: {} };
}

export const Point: MessageFns<Point> = {
  encode(message: Point, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    writer.uint32(18).fork();
    for (const v of message.vector) {
      writer.float(v);
    }
    writer.join();
    Object.entries(message.payload).forEach(([key, value]) => {
      Point_PayloadEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Point {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag === 21) {
            message.vector.push(reader.float());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.vector.push(reader.float());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = Point_PayloadEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.payload[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Point {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      vector: globalThis.Array.isArray(object?.vector) ? object.vector.map((e: any) => globalThis.Number(e)) : [],
      payload: isObject(object.payload)
        ? Object.entries(object.payload).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Point): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.vector?.length) {
      obj.vector = message.vector;
    }
    if (message.payload) {
      const entries = Object.entries(message.payload);
      if (entries.length > 0) {
        obj.payload = {};
        entries.forEach(([k, v]) => {
          obj.payload[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Point>, I>>(base?: I): Point {
    return Point.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Point>, I>>(object: I): Point {
    const message = createBasePoint();
    message.id = object.id ?? "";
    message.vector = object.vector?.map((e) => e) || [];
    message.payload = Object.entries(object.payload ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBasePoint_PayloadEntry(): Point_PayloadEntry {
  return { key: "", value: "" };
}

export const Point_PayloadEntry: MessageFns<Point_PayloadEntry> = {
  encode(message: Point_PayloadEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Point_PayloadEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePoint_PayloadEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Point_PayloadEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Point_PayloadEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Point_PayloadEntry>, I>>(base?: I): Point_PayloadEntry {
    return Point_PayloadEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Point_PayloadEntry>, I>>(object: I): Point_PayloadEntry {
    const message = createBasePoint_PayloadEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

export type VectronServiceService = typeof VectronServiceService;
export const VectronServiceService = {
  createCollection: {
    path: "/vectron.v1.VectronService/CreateCollection",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateCollectionRequest): Buffer =>
      Buffer.from(CreateCollectionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateCollectionRequest => CreateCollectionRequest.decode(value),
    responseSerialize: (value: CreateCollectionResponse): Buffer =>
      Buffer.from(CreateCollectionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CreateCollectionResponse => CreateCollectionResponse.decode(value),
  },
  upsert: {
    path: "/vectron.v1.VectronService/Upsert",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpsertRequest): Buffer => Buffer.from(UpsertRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpsertRequest => UpsertRequest.decode(value),
    responseSerialize: (value: UpsertResponse): Buffer => Buffer.from(UpsertResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): UpsertResponse => UpsertResponse.decode(value),
  },
  search: {
    path: "/vectron.v1.VectronService/Search",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SearchRequest): Buffer => Buffer.from(SearchRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SearchRequest => SearchRequest.decode(value),
    responseSerialize: (value: SearchResponse): Buffer => Buffer.from(SearchResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SearchResponse => SearchResponse.decode(value),
  },
  get: {
    path: "/vectron.v1.VectronService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetRequest): Buffer => Buffer.from(GetRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetRequest => GetRequest.decode(value),
    responseSerialize: (value: GetResponse): Buffer => Buffer.from(GetResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetResponse => GetResponse.decode(value),
  },
  delete: {
    path: "/vectron.v1.VectronService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteRequest): Buffer => Buffer.from(DeleteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteRequest => DeleteRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  listCollections: {
    path: "/vectron.v1.VectronService/ListCollections",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListCollectionsRequest): Buffer =>
      Buffer.from(ListCollectionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListCollectionsRequest => ListCollectionsRequest.decode(value),
    responseSerialize: (value: ListCollectionsResponse): Buffer =>
      Buffer.from(ListCollectionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListCollectionsResponse => ListCollectionsResponse.decode(value),
  },
} as const;

export interface VectronServiceServer extends UntypedServiceImplementation {
  createCollection: handleUnaryCall<CreateCollectionRequest, CreateCollectionResponse>;
  upsert: handleUnaryCall<UpsertRequest, UpsertResponse>;
  search: handleUnaryCall<SearchRequest, SearchResponse>;
  get: handleUnaryCall<GetRequest, GetResponse>;
  delete: handleUnaryCall<DeleteRequest, DeleteResponse>;
  listCollections: handleUnaryCall<ListCollectionsRequest, ListCollectionsResponse>;
}

export interface VectronServiceClient extends Client {
  createCollection(
    request: CreateCollectionRequest,
    callback: (error: ServiceError | null, response: CreateCollectionResponse) => void,
  ): ClientUnaryCall;
  createCollection(
    request: CreateCollectionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateCollectionResponse) => void,
  ): ClientUnaryCall;
  createCollection(
    request: CreateCollectionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateCollectionResponse) => void,
  ): ClientUnaryCall;
  upsert(
    request: UpsertRequest,
    callback: (error: ServiceError | null, response: UpsertResponse) => void,
  ): ClientUnaryCall;
  upsert(
    request: UpsertRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpsertResponse) => void,
  ): ClientUnaryCall;
  upsert(
    request: UpsertRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpsertResponse) => void,
  ): ClientUnaryCall;
  search(
    request: SearchRequest,
    callback: (error: ServiceError | null, response: SearchResponse) => void,
  ): ClientUnaryCall;
  search(
    request: SearchRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SearchResponse) => void,
  ): ClientUnaryCall;
  search(
    request: SearchRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SearchResponse) => void,
  ): ClientUnaryCall;
  get(request: GetRequest, callback: (error: ServiceError | null, response: GetResponse) => void): ClientUnaryCall;
  get(
    request: GetRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetResponse) => void,
  ): ClientUnaryCall;
  get(
    request: GetRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetResponse) => void,
  ): ClientUnaryCall;
  delete(
    request: DeleteRequest,
    callback: (error: ServiceError | null, response: DeleteResponse) => void,
  ): ClientUnaryCall;
  delete(
    request: DeleteRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeleteResponse) => void,
  ): ClientUnaryCall;
  delete(
    request: DeleteRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeleteResponse) => void,
  ): ClientUnaryCall;
  listCollections(
    request: ListCollectionsRequest,
    callback: (error: ServiceError | null, response: ListCollectionsResponse) => void,
  ): ClientUnaryCall;
  listCollections(
    request: ListCollectionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListCollectionsResponse) => void,
  ): ClientUnaryCall;
  listCollections(
    request: ListCollectionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListCollectionsResponse) => void,
  ): ClientUnaryCall;
}

export const VectronServiceClient = makeGenericClientConstructor(
  VectronServiceService,
  "vectron.v1.VectronService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): VectronServiceClient;
  service: typeof VectronServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
